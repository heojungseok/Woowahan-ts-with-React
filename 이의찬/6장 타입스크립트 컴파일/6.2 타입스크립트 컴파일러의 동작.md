### 코드 검사기로서의 타입스크립트 컴파일러

타입스크립트 컴파일러는 코드에 타입 오류가 없는지 확인한다. 컴파일타임에 코드 타입을 확인하기 때문에 코드를 실행하지 않고도 오류를 바로 알 수 있다.

타입스크립트는 정적으로 코드를 분석하여 에러를 검출하며, 코드를 실행하기 전에 자바스크립트 런타임에서 발생할 수 있는 에러를 사전에 알려준다. 컴파일타임에 문법 에러와 타입 관련 에러를 모두 검출한다.

```tsx
const developer = {
  work() {
    console.log("working...");
  },
};

developer.work(); // working...
developer.sleep(); // Property 'sleep' does not exist on type '{ work(): void;}'

```

자바스크립트에서는 런타임에서 발견할 수 있는 에러를 타입스크립트에서는 컴파일타임에 발견하여 실행 과정에서 발생할 수 있는 문제를 방지한다.

타입스크립트 컴파일러는 `tsc binder`를 사용하여 타입 검사를 하며, 컴파일타임에 타입 오류를 발견한다. 타입 검사를 거쳐 코드를 안전하게 만든 이후에는 타입스크립트 AST를 자바스크립트 코드로 변환한다.

### 코드 변환기로서의 타입스크립트 컴파일러

타입스크립트 컴파일러는 타입을 검사한 다음에 타입스크립트 코드를 각자의 런타임 환경에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.

타입스크립트 소스코드는 브라우저 같은 런타임에서 실행될 수 없다. 타입스크립트 소스코드를 파싱하고 자바스크립트 코드로 변환해야 비로소 실행할 수 있게 된다.

타입스크립트 컴파일러의 `target` 옵션을 사용하여 특정 버전의 자바스크립트 소스코드로 컴파일할 수 있다.

```tsx
// TypeScript
type Fruit = "banana" | "apple" | "mango" | "watermelon" | "orange" | "kiwi";
const fruitBox: Fruit[] = ["banana", "apple", "mango"];

const welcome = (name: string) => {
  console.log(`hi! ${name} :)`);
};

```

```jsx
// JavaScript (ES5로 컴파일)
"use strict";
var fruitBox = ["banana", "apple", "mango"];
var welcome = function (name) {
  console.log("hi! ".concat(name, " :)"));
};

```

트랜스파일이 완료된 자바스크립트 파일에서 타입 정보가 제거되었다. 타입스크립트가 자바스크립트로 컴파일되어야 브라우저는 코드를 이해하고 정상적으로 실행할 수 있다.

**중요**: 타입스크립트 컴파일러는 타입 검사를 수행한 후 코드 변환을 시작하는데, 이때 타입 오류가 있더라도 일단 컴파일을 진행한다. 타입스크립트 코드가 자바스크립트 코드로 변환되는 과정은 타입 검사와 독립적으로 동작하기 때문이다.

```tsx
const name: string = "zig";
const age: number = "zig"; // Type 'string' is not assignable to type 'number'

```

위 코드는 타입 에러가 발생하지만 자바스크립트로 컴파일할 수는 있다:

```jsx
const name = "zig";
const age = "zig";

```

타입스크립트 컴파일 이후에는 타입이 제거되어 순수한 자바스크립트 코드만 남는다. 컴파일된 코드가 실행되고 있는 런타임에서는 타입 검사를 할 수 없기 때문에 주의해야 한다.

```tsx
interface Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    // 'Rectangle' only refers to a type, but is being used as a value here
    // Property 'height' does not exist on type 'Shape'
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}

```

`instanceof` 체크는 런타임에 실행되지만 `Rectangle`은 타입이기 때문에 자바스크립트 런타임은 해당 코드를 이해하지 못한다. 타입스크립트 코드가 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문이 제거되어 버리기 때문에 런타임에서는 타입을 사용할 수 없다.

**타입스크립트 컴파일러의 역할 정리**

- 최신 버전의 타입스크립트/자바스크립트 코드를 구버전의 자바스크립트로 트랜스파일한다
- 코드의 타입 오류를 검사한다

### 바벨(Babel)과의 차이

바벨은 ECMAScript 2015 이후의 코드를 현재 또는 오래된 브라우저와 호환되는 버전으로 변환해주는 자바스크립트 컴파일러다.

`tsc`와 바벨은 소스코드를 ES5 이하의 자바스크립트 코드로 컴파일해준다는 점에서는 동일하다. 하지만 `tsc`와 달리 바벨은 타입 검사를 하지 않는다. 최신 버전의 자바스크립트 코드를 낮은 버전으로 컴파일하는 것이 바벨의 주된 역할이다.