웹 프론트엔드는 데이터베이스에 직접 접근할 수 없다. 보통 백엔드 서버가 데이터베이스를 담당하고, 프론트엔드는 HTTP 프로토콜을 통해 백엔드와 통신한다. 주로 GET, POST 같은 메서드와 URI를 활용하는 REST API를 사용한다.

API 요청과 응답은 모두 비동기로 이루어진다. 비동기 처리를 할 때는 다음 사항들을 고려해야 한다

- 현재 비동기 동작이 어떤 상태인가?
- 비동기 동작을 위해 필요한 정보가 무엇인가?
- 요청이 성공했다면 받아온 정보를 어떻게 저장하고 관리할 것인가?
- 요청이 실패했다면 실패에 대한 정보를 어떻게 확인할 것인가?
- 비동기 요청에 대한 코드를 쉽게 유지보수할 수 있도록 어떻게 구조화하고 관리할 것인가?

## 7.1 API 요청

### fetch로 API 요청하기

신입 개발자가 장바구니 조회 기능을 만들었다. fetch 함수를 직접 사용해서 장바구니 물품 개수를 배지로 보여주는 코드를 작성했다.

```tsx
import React, { useEffect, useState } from "react";

const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    fetch("https://api.baemin.com/cart")
      .then((response) => response.json())
      .then(({ cartItem }) => {
        setCartCount(cartItem.length);
      });
  }, []);

  return <>{/* cartCount 상태를 이용하여 컴포넌트 렌더링 */}</>;
};

```

여러 곳에서 같은 API URL을 복붙하여 사용하게 되었다. 그런데 백엔드에서 API URL을 수정해야 한다고 한다. 컴포넌트 내부에 깊숙이 자리 잡은 비동기 호출 코드는 이러한 변경 요구에 취약하다. URL 변경뿐 아니라 타임아웃 설정, 커스텀 헤더 추가 같은 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다.

### 서비스 레이어로 분리하기

여러 API 요청 정책이 추가될 수 있다는 것을 감안한다면, 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 한다.

fetch 함수를 호출하는 부분이 서비스 레이어로 이동하고, 컴포넌트는 서비스 레이어의 비동기 함수를 호출하여 그 결과를 받아와 렌더링하는 흐름이 된다.

그러나 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵다. 예를 들어 fetch 함수에서 타임아웃을 설정하려면 다음과 같이 구현해야 한다

```tsx
async function fetchCart() {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 5000);

  const response = await fetch("https://api.baemin.com/cart", {
    signal: controller.signal,
  });

  clearTimeout(timeoutId);
  return response;
}

```

쿼리 매개변수나 커스텀 헤더 추가, 쿠키를 읽어 토큰을 집어넣는 등 다양한 API 정책을 모두 구현하는 것은 번거로운 일이다.

### Axios 활용하기

fetch는 내장 라이브러리라 별도 설치 없이 사용할 수 있지만, 많은 기능을 직접 구현해야 한다. 이런 번거로움 때문에 Axios 라이브러리를 사용한다.

```tsx
const apiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});

const fetchCart = (): AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse>("cart");

const postCart = (postCartRequest: PostCartRequest): AxiosPromise<PostCartResponse> =>
  apiRequester.post<PostCartResponse>("cart", postCartRequest);

```

각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.

API Entry가 2개 이상일 경우에는 각 서버의 기본 URL을 호출하도록 여러 개의 API 요청 인스턴스를 따로 구성해야 한다

```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);

const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});

```

### Axios 인터셉터 사용하기

각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수 있다.

인터셉터 기능을 사용하여 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있다. 또한 API 에러를 처리할 때 하나의 에러 객체로 묶어서 처리할 수도 있다.

```tsx
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

const apiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});

const setRequestDefaultHeader = (requestConfig: AxiosRequestConfig) => {
  const config = requestConfig;
  config.headers = {
    ...config.headers,
    "Content-Type": "application/json;charset=utf-8",
    user: getUserToken(),
    agent: getAgent(),
  };
  return config;
};

// interceptors 기능을 사용해 header를 설정하는 기능을 넣거나 에러를 처리할 수 있다
apiRequester.interceptors.request.use(setRequestDefaultHeader);

const orderApiRequester: AxiosInstance = axios.create({
  baseURL: orderApiBaseUrl,
  ...defaultConfig,
});

// 기본 apiRequester와는 다른 header를 설정하는 interceptors
orderApiRequester.interceptors.request.use(setOrderRequestDefaultHeader);

// interceptors를 사용해 httpError 같은 API 에러를 처리할 수도 있다
orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response,
  httpErrorHandler
);

```

요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.

- 빌더 패턴(Builder Pattern)은 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴
    - 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공

기본 API 클래스로 실제 호출 부분을 구성하고, API를 호출하기 위한 래퍼(Wrapper)를 빌더 패턴으로 만든다

```tsx
class API {
  readonly method: HTTPMethod;
  readonly url: string;
  baseURL?: string;
  headers?: HTTPHeaders;
  params?: HTTPParams;
  data?: unknown;
  timeout?: number;
  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url;
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();

    // withCredential이 설정된 API라면 인터셉터를 추가하고, 아니라면 사용하지 않음
    if (this.withCredentials) {
      http.interceptors.response.use(
        response => response,
        error => {
          if (error.response && error.response.status === 401) {
            /* 에러 처리 진행 */
          }
          return Promise.reject(error);
        }
      );
    }

    return http.request({ ...this });
  }
}

```

APIBuilder 클래스를 사용하는 코드

```tsx
const fetchJobNameList = async (name?: string, size?: number) => {
  const api = APIBuilder.get("/apis/web/jobs")
    .withCredentials(true) // 401 에러가 나는 경우, 자동으로 에러를 탐지하는 인터셉터를 사용
    .params({ name, size }) // body가 없는 axios 객체도 빌더 패턴으로 쉽게 만들 수 있다
    .build();

  const { data } = await api.call<Response<JobNameListResponse>>();
  return data;
};

```

APIBuilder 클래스는 보일러플레이트 코드가 많다는 단점이 있다. 하지만 옵션이 다양한 경우에 인터셉터를 설정값에 따라 적용하고, 필요 없는 인터셉터를 선택적으로 사용할 수 있다는 장점도 있다.

**보일러플레이트(Boilerplate) 코드**는 어떤 기능을 사용할 때 반복적으로 사용되는 기본적인 코드를 말한다. 예를 들어 API를 호출하기 위한 기본적인 설정과 인터셉터 등을 설정하는 부분을 보일러플레이트 코드로 간주할 수 있다.

### API 응답 타입 지정하기

같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다

```tsx
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR
  errorMessage?: string; // FAIL, ERROR
}

const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>>("cart");

const postCart = (postCartRequest: PostCartRequest): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);

```

서버에서 오는 응답을 통일해줄 때 주의할 점이 있다. Response 타입을 apiRequester 내에서 처리하고 싶은 생각이 들 수 있는데, 이렇게 하면 UPDATE나 CREATE같이 응답이 없을 수 있는 API를 처리하기 까다로워진다.

따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.

API 요청 및 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있다. 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현한다

```tsx
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  }
}

```

forPass 안에 프론트 로직에서 사용해야 하는 값이 있다면, 여전히 어떤 값이 들어올지 모르는 상태이기 때문에 unknown을 유지한다. 로그를 위해 단순히 받아서 넘겨주는 값의 타입은 언제든지 변경될 수 있으므로 forPass 내의 값을 사용하지 않아야 한다. 다만 이미 설계된 프로덕트에서 쓰고 있는 값이라면 프론트 로직에서 써야 하는 값에 대해서만 타입을 선언한 다음에 사용하는 게 좋다

```tsx
type ForPass = {
  type: "A" | "B" | "C";
};

const isTargetValue = () => (data.forPass as ForPass).type === "A";

```

### 뷰 모델(View Model) 사용하기

API 응답은 변할 가능성이 크다. 특히 새로운 프로젝트는 서버 스펙이 자주 바뀌기 때문에 뷰 모델(View Model)을 사용하여 API 변경에 따른 범위를 한정해줘야 한다.

특정 객체 리스트를 조회하여 리스트 각각의 내용과 리스트 전체 길이 등을 보여줘야 하는 화면을 떠올려보자:

```tsx
interface ListResponse {
  items: ListItem[];
}

const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<ListResponse>>();

  return { data };
};

```

해당 API를 사용할 때

```tsx
const ListPage: React.FC = () => {
  const [totalItemCount, setTotalItemCount] = useState(0);
  const [items, setItems] = useState<ListItem[]>([]);

  useEffect(() => {
    fetchList(filter).then(({ items }) => {
      setCartCount(items.length);
      setItems(items);
    });
  }, []);

  return (
    <div>
      <Chip label={totalItemCount}/>
      <Table items={items} />
    </div>
  );
};

```

좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 말한다. API 응답의 items 인자를 좀 더 정확한 개념으로 나타내기 위해 jobItems나 cartItems 같은 이름으로 수정하면 해당 컴포넌트도 수정해야 한다. 이렇게 수정해야 할 컴포넌트가 API 1개에 하나라면 좋겠지만, API를 사용하는 기존 컴포넌트도 수정되어야 한다. 보통 이런 상황이 프로젝트 초기에 자주 발생하곤 한다.

이러한 문제를 해결하기 위한 방법으로 뷰 모델을 도입할 수 있다

```tsx
interface JobListItemResponse {
  name: string;
}

interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems;
  }
}

const fetchJobList = async (filter?: ListFetchFilter): Promise<JobListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<JobListResponse>>();

  return new JobList(data);
};

```

뷰 모델을 만들면 API 응답이 바뀌어도 UI가 깨지지 않게 개발할 수 있다. 또한 API 응답에는 없는 totalItemCount 같은 도메인 개념을 넣을 때 백엔드나 UI에서 로직을 추가하여 처리할 필요 없이 간편하게 새로운 필드를 뷰 모델에 추가할 수 있다.

그러나 뷰 모델 방식에서도 문제가 발생할 수 있다. 추상화 레이어 추가는 결국 코드를 복잡하게 만들며 레이어를 관리하고 개발하는 데도 비용이 든다. 단순히 API 20개를 추가한다면 20개 이상 뷰 모델이 추가될 수 있다. API 응답에는 없는 새로운 필드를 만들어서 사용할 때, 서버가 내려준 응답과 클라이언트가 실제 사용하는 도메인이 다르다면 서버와 클라이언트 간의 의사소통 문제가 생길 수 있다.

결국 API 응답이 바뀌었을 때는 클라이언트 코드를 수정하는 데 들어가는 비용을 줄이면서도 도메인의 일관성을 지킬 수 있는 절충안을 찾아야 한다

- 꼭 필요한 곳에만 뷰 모델을 부분적으로 만들어서 사용하기
- 백엔드와 클라이언트 개발자가 충분히 소통한 다음에 개발하여 API 응답 변화를 최대한 줄이기
- 뷰 모델에 필드를 추가하는 대신에 getter 등의 함수를 추가하여 실제 어떤 값이 뷰 모델에 추가한 값인지 알기 쉽게 하기