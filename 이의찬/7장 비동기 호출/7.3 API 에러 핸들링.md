# **3. API 에러 핸들링**

비동기 API 호출 시 401(인증 실패), 404(리소스 없음), 500(서버 에러), CORS 에러 등 다양한 에러가 발생할 수 있다. TypeScript에서 이런 에러를 명시적으로 처리하는 방법을 살펴보자.

### 1. 타입 가드 활용하기

Axios는 `isAxiosError`라는 타입 가드를 제공한다. 서버 에러를 명확하게 표시하고 에러 응답 객체를 구체적으로 정의하면 에러 객체의 속성을 정확히 파악할 수 있다.

먼저 서버에서 전달하는 공통 에러 객체 타입을 정의한다

```tsx
interface ErrorResponse {
  status: string;
  serverDateTime: string;
  errorCode: string;
  errorMessage: string;
}
```

이를 활용해 타입 가드를 작성한다

```tsx
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```

**참고:** 사용자 정의 타입 가드는 반환 타입으로 `parameterName is Type` 형태의 타입 명제(type predicate)를 정의하는 게 좋다.

실제 사용 예시

```tsx
const onClickDeleteHistoryButton = async (id: string) => {
  try {
    await [axios.post](http://axios.post)("https://...", { id });
    alert("주문 내역이 삭제되었습니다.");
  } catch (error: unknown) {
    if (isServerError(error) && error.response && [error.response.data](http://error.response.data).errorMessage) {
      // 서버 에러임을 명시적으로 알 수 있다
      setErrorMessage([error.response.data](http://error.response.data).errorMessage);
      return;
    }
    setErrorMessage("일시적인 에러가 발생했습니다. 잠시 후 다시 시도해주세요");
  }
};
```

## 2. 에러 서브클래싱하기

인증 에러, 네트워크 에러, 타임아웃 에러 등 다양한 에러를 더 명시적으로 표시하려면 서브클래싱(Subclassing)을 활용할 수 있다.

**서브클래싱:** 기존 클래스를 확장하여 새로운 클래스를 만드는 과정. 상위 클래스의 모든 속성과 메서드를 상속받아 사용할 수 있고, 추가 속성과 메서드도 정의할 수 있다.

커스텀 에러 클래스 정의

```tsx
class OrderHttpError extends Error {
  private readonly privateResponse: AxiosResponse<ErrorResponse> | undefined;

  constructor(message?: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    [this.name](http://this.name) = "OrderHttpError";
    this.privateResponse = response;
  }

  get response(): AxiosResponse<ErrorResponse> | undefined {
    return this.privateResponse;
  }
}

class NetworkError extends Error {
  constructor(message = "") {
    super(message);
    [this.name](http://this.name) = "NetworkError";
  }
}

class UnauthorizedError extends Error {
  constructor(message: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    [this.name](http://this.name) = "UnauthorizedError";
  }
}
```

Axios 인터셉터에서 적합한 에러 객체 전달

```tsx
const httpErrorHandler = (
  error: AxiosError<ErrorResponse> | Error
): Promise<Error> => {
  let promiseError: Promise<Error>;

  if (axios.isAxiosError(error)) {
    if ([Object.is](http://Object.is)(error.code, "ECONNABORTED")) {
      promiseError = Promise.reject(new TimeoutError());
    } else if ([Object.is](http://Object.is)(error.message, "Network Error")) {
      promiseError = Promise.reject(new NetworkError(""));
    } else {
      const { response } = error as AxiosError<ErrorResponse>;
      switch (response?.status) {
        case HttpStatusCode.UNAUTHORIZED:
          promiseError = Promise.reject(
            new UnauthorizedError(response?.data.message, response)
          );
          break;
        default:
          promiseError = Promise.reject(
            new OrderHttpError(response?.data.message, response)
          );
      }
    }
  } else {
    promiseError = Promise.reject(error);
  }

  return promiseError;
};
```

에러 처리

```tsx
const onActionError = (
  error: unknown,
  params?: Omit<AlertPopup, "type" | "message">
) => {
  if (error instanceof UnauthorizedError) {
    onUnauthorizedError(
      error.message,
      errorCallback?.onUnauthorizedErrorCallback
    );
  } else if (error instanceof NetworkError) {
    alert("네트워크 연결이 원활하지 않습니다. 잠시 후 다시 시도해주세요.", {
      onClose: errorCallback?.onNetworkErrorCallback,
    });
  } else if (error instanceof OrderHttpError) {
    alert(error.message, params);
  } else if (error instanceof Error) {
    alert(error.message, params);
  } else {
    alert(defaultHttpErrorMessage, params);
  }
};
```

서브클래싱을 사용하면 `error instanceof OrderHttpError`와 같은 타입 가드문으로 코드상에서 에러 핸들링 부분을 한눈에 볼 수 있다.

## 3. 인터셉터를 활용한 에러 처리

Axios의 인터셉터(interceptors) 기능을 사용하면 HTTP 에러에 일관된 로직을 적용할 수 있다.

```tsx
const httpErrorHandler = (
  error: AxiosError<ErrorResponse> | Error
): Promise<Error> => {
  return (error) => {
    // 401 에러인 경우 로그인 페이지로 이동
    if (error.response && error.response.status === 401) {
      window.location.href = `${backOfficeAuthHost}/login?targetUrl=${window.location.href}`;
    }
    return Promise.reject(error);
  };
};

orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response,
  httpErrorHandler
);
```

## 4. 에러 바운더리를 활용한 에러 처리

에러 바운더리는 리액트 컴포넌트 트리에서 에러가 발생할 때 공통으로 에러를 처리하는 리액트 컴포넌트다. 하위 컴포넌트에서 발생한 에러를 캐치하고, 가장 가까운 부모 에러 바운더리에서 처리하게 할 수 있다.

```tsx
import React, { ErrorInfo } from "react";
import ErrorPage from "pages/ErrorPage";

interface ErrorBoundaryProps {}

interface ErrorBoundaryState {
  hasError: boolean;
}

class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    this.setState({ hasError: true });
    console.error(error, errorInfo);
  }

  render(): React.ReactNode {
    const { children } = this.props;
    const { hasError } = this.state;
    return hasError ? <ErrorPage /> : children;
  }
}

const App = () => {
  return (
    <ErrorBoundary>
      <OrderHistoryPage />
    </ErrorBoundary>
  );
};
```

## 5. 상태 관리 라이브러리에서의 에러 처리

### Redux에서의 에러 처리

```tsx
// API 호출에 관한 reducer
const apiCallSlice = createSlice({
  name: "apiCall",
  initialState,
  reducers: {
    setApiCall: (state, { payload: { status, urlInfo }}) => {
      /* API State를 채우는 logic */
    },
    setApiCallError: (state, { payload }: PayloadAction<any>) => {
      state.error = payload;
    },
  },
});
```

인터셉터에서 에러 처리

```tsx
const setAxiosInterceptor = (store: EnhancedStore) => {
  API.interceptors.response.use(
    (response: AxiosResponse) => {
      const { method, url } = response.config;
      store.dispatch(
        setApiCall({
          status: ApiCallStatus.None,
          urlInfo: { url, method },
        })
      );
      return response?.data?.data || response?.data;
    },
    (error: AxiosError) => {
      // 401 unauthorized
      if (error.response?.status === 401) {
        window.location.href = error.response.headers.location;
        return;
      }
      // 403 forbidden
      else if (error.response?.status === 403) {
        window.location.href = error.response.headers.location;
        return;
      }
      // 그 외에는 화면에 alert 띄우기
      else {
        message.error(`[서버 요청 에러]: ${error?.response?.data?.message}`);
      }

      const {
        config: { url, method },
      } = error;

      store.dispatch(
        setApiCall({
          status: ApiCallStatus.None,
          urlInfo: { url, method },
        })
      );

      return Promise.reject(error);
    }
  );
};
```

액션에서 에러 처리

```tsx
const fetchMenu = createAsyncThunk(
  FETCH_MENU_REQUEST,
  async ({ shopId, menuId }: FetchMenu) => {
    try {
      const data = await api.fetchMenu(shopId, menuId);
      return data;
    } catch (error) {
      setApiCallError({ error });
    }
  }
);
```

### MobX에서의 에러 처리

```tsx
class JobStore {
  jobs: Job[] = [];
  state: LoadingState = "PENDING"; // "PENDING" | "DONE" | "ERROR"
  errorMsg = "";

  constructor() {
    makeAutoObservable(this);
  }

  async fetchJobList() {
    [this.jobs](http://this.jobs) = [];
    this.state = "PENDING";
    this.errorMsg = "";

    try {
      const projects = await fetchJobList();
      runInAction(() => {
        this.projects = projects;
        this.state = "DONE";
      });
    } catch (e: any) {
      runInAction(() => {
        // 에러 핸들링 코드를 작성
        this.state = "ERROR";
        this.errorMsg = e.message;
        showAlert();
      });
    }
  }

  get isLoading(): boolean {
    return this.state === "PENDING";
  }
}
```

## 6. react-query를 활용한 에러 처리

react-query나 swr 같은 데이터 페칭 라이브러리를 사용하면 요청 상태를 반환해주기 때문에 확인하기 쉽다.

```tsx
const JobComponent: React.FC = () => {
  const { isError, error, isLoading, data } = useFetchJobList();

  if (isError) {
    return <div>{`${error.message}가 발생했습니다. 나중에 다시 시도해주세요.`}</div>;
  }

  if (isLoading) {
    return <div>로딩 중입니다.</div>;
  }

  return <>{[data.map](http://data.map)((job) => <JobItem key={[job.id](http://job.id)} job={job} />)}</>;
};
```

## 7. 그 밖의 에러 처리

API 응답은 주로 성공 시 2xx 코드를, 실패 시 4xx, 5xx 코드를 반환한다. 그러나 비즈니스 로직의 유효성 검증으로 추가된 커스텀 에러는 200 응답과 함께 응답 바디에 별도의 상태 코드를 전달하기도 한다.

예시:

```
httpStatus: 200
{
  "status": "C20005", // 성공인 경우 "SUCCESS"를 응답
  "message": "장바구니에 품절된 메뉴가 있습니다."
}
```

### 요청 함수 내에서 조건문으로 처리

```tsx
const successHandler = (response: CreateOrderResponse) => {
  if (response.status === "SUCCESS") {
    // 성공 시 진행할 로직을 추가한다
    return;
  }
  throw new CustomError(response.status, response.message);
};

const createOrder = (data: CreateOrderData) => {
  try {
    const response = [apiRequester.post](http://apiRequester.post)("https://...", data);
    successHandler(response);
  } catch (error) {
    errorHandler(error);
  }
};
```

### 인터셉터에서 일괄 처리

특정 호스트에 대한 API requester를 별도로 선언하고 상태 코드 비교 로직을 인터셉터에 추가할 수 있다.

```tsx
export const apiRequester: AxiosInstance = axios.create({
  baseURL: orderApiBaseUrl,
  ...defaultConfig,
});

export const httpSuccessHandler = (response: AxiosResponse) => {
  if ([response.data](http://response.data).status !== "SUCCESS") {
    throw new CustomError(response?.data.message, response);
  }
  return response;
};

apiRequester.interceptors.response.use(httpSuccessHandler, httpErrorHandler);
```

이렇게 하면 외부에서 200번대로 온 응답이라도 400번대, 500번대 같은 에러로 받게 된다. 성공 핸들러에서는 성공인 경우의 동작만 작성하고, 에러 핸들러에서 커스텀 에러를 처리할 수 있다.