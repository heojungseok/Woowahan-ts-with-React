# 3.1 타입스크립트만의 독자적 타입 시스템

Ts의 타입 시스템은 모두 Js에서 기인했다. 하지만 Js로 표현할 수단과 필요성이 없었을 뿐.

예를 들어 `any`의 경우 Ts에만 존재하는 독자적인 시스템이다. `typeof`나 `Object.prototype.toString.call(...)`을 사용해서 변수 타입을 추적해도 `any`라는 문자열을 반환하지 않는다.

근데 `any`타입의 개념 자체는 Js에서 이미 널리 사용되고 있다. Js의 사용 방식이 어디든 매핑 가능한 `any`타입 그 자체다. 이 외의 모든 타입 시스템도 Ts에서만 존재하지만, 그 개념은 Js에서 기인한다.

![image.png](attachment:9c7f547d-5ed6-43cc-afad-9677e59673dc:image.png)

### any 타입

`any`타입은 모든 타입의 값이 할당될 수 있다. 고로 Ts의 목적인 정적 타이핑을 무효화시킨다. 

하지만 다음의 경우에는 고려해볼 수 있다.

1. 개발 단계에서 임시로 값을 지정할 때
    
    값이 변경될 가능성이 있거나, 세부 항목에 대한 타입이 확정되지 않았을 때 임시로 `any`타입을 사용
    
2. 어떤 값을 받아올지 or 넘겨줄지 정할 수 없을 때
    
    API 요청 및 응답 처리, 콜백 함수 전달, 타입이 잘 정제되지 않은 외부 라이브러리 등
    
    ```tsx
    type FeedbackModalParams = {
    	// 다양한 action 함수를 전달하기 위해서 any타입 사용
    	// 하지만, 함수 외의 다른 값을 넘겨줘도 에러가 발생하지 않음 -> 사용을 지양하는 이유
    	action?： any;
    }；
    ```
    
3. 값을 예측할 수 없을 때
    
    ```tsx
    async function load() {
    	const response = await fetch("https：//api.com”);
    	// response.json()등 fetch API의 일부 메서드는 리턴 타입이 Promise<any>로 정의되어 있다
    	const data = await response.json();
    	return data;
    }
    ```
    

### unknown 타입

`any`를 제외한 다른 타입으로 이미 선언된 변수를 제외하고는 `any`타입처럼 모든 타입의 값이 할당 가능하다.

하지만 할당이 가능한거지, 함수를 실행하거나, 객체의 값을 가져오거나, 내부 속성에 접근은 불가능하다.

```tsx
// 할당 시점에서는 에러가 발생하지 않음
const unknownFunction： unknown = () => console.log("this is unknown type");
// 하지만 실행 시에는 에러가 발생; Error： Object is of type 'unknown'.ts (2571)
unknownFunction();
```

타입 검사를 강제하고, 타입이 식별된 후 사용할 수 있기에, 데이터 구조 파악이 어려울 때 `any`타입을 대체하기 위한 용도로 등장했다.

> any = 무엇이든 OK, unknown = 뭔지 모르지만, 테스트하면서 알아내보자
> 

### void 타입

함수의 return값이 없는 걸 표현하기 위해 사용된다. 근데 어차피 명시안해도 알아서 컴파일러가 `void`로 추론해준다.

변수에도 사용할 수 있다. `void`로 선언된 변수는 `null`혹은 `undefined`를 할당할 수 있다. 근데 명시적 표현을 위해서 그냥 `null`혹은 `undefined`를 직접 선언하는게 낫다. 

### never 타입

함수에서 값을 반환할 수 없을 때 사용하는 타입. 

1. 에러를 던지는 경우
    
    `throw`로 에러를 던지는 것은 값을 반환하는 것으로 판단되지 않는다. 마지막에 에러를 던지는 함수라면 반환 타입으로 `never`를 사용한다.
    
    ```tsx
    function generateError(res： Response)： never{
    	throw new Error(res.getMessage();
    }
    ```
    
2. 무한히 함수가 실행되는 경우

### Array 타입

```tsx
const arr = [];

// Js에서도 Object.prototype.toString.call(...)을 사용해서 확인할 수 있다.
console.log(Object.prototype.toString.call(arr)); // '[object Array]'

// 그냥 typeof로 찍으면 object로 나오니까 주의.
console.log(typeof arr); // object
```

기본적으로 Js의 배열은 Java, C등과 다르게 뭐든 넣을 수 있다.

```tsx
const array: Array<any> = [1, "string", fn];
// 숫자만 담을 수 있다.
const numberArray: Array<number>= [1, 2, 3]
// Array<number>와 number[]는 취향차이
const numberArray2: number[] = [1, 2, 3]
```

`[]`를 사용해서 type을 명시할 경우, 배열보다 좁은 범위인 튜플을 가리키게 된다. 튜플은 정적 언어들의 타입처럼 길이까지 제한해서 원소의 개수와 타입을 보장한다.

```tsx
let tuple： [number] = [1];
tuple = [1, 2]； // 불가능
tuple = [1, "string"]; // 불가능

// 여러 타입과 혼합도 가능
let tuple： [number, string, boolean] = [1, "string", true];
```

이런 튜플의 특성을 사용한 것이 React의 useState API다. 

첫 번째 요소는 늘 상태 값, 두 번째 요소는 업데이트 함수로 고정되어 있고 수정이나 추가가 불가능하다. 또한 자유롭게 네이밍이 가능하다.

```tsx
const [value, setValue] = useState(false);
const [username, setUsername] = useState('');

// 객체였다면 이렇게 해야 했을 것
const { state: value, setState: setValue } = useState(false);
const { state: name, setState: setName } = useState('');
```

### enum 타입

열거형 타입으로 주로 문자열 상수를 생성하는데 사용. 

기본적으로 0부터 1씩 늘려가면서 값을 할당한다. 만약 명시적으로 값을 할당할 경우, 이전 멤버의 값을 기준으로 1씩 늘려가면서 자동으로 할당한다.

```tsx
enum ProgrammingLanguage {
	Typescript, // 0
	Javascript, // 1
	Java, // 2
	Python = 300, // 3
	Kotlin = 400, // 4
	Rust, // 401
	Go, // 402
}

```

문제는 타입 공간과 값 공간에서 모두 사용되기 때문에, 컴파일 될 때 즉시 실행 함수 형식으로 변환된다. 그래서 일부 번들러에서 변환된 값을 사용하는지의 여부를 제대로 체크하지 못하고 트리 쉐이킹에서 놓치는 경우가 있다.

> React Native의 번들러가 대표적인 경우.
>