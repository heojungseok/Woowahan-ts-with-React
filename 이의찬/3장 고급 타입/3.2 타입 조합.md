## 3.2 타입 조합

교차 타입(Intersection)과 유니온 타입(Union)은 생략..

### 인덱스 시그니처**(Index Signatures)**

특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용하는 문법

[Key: K]: T꼴로 타입을 명시 → 해당 타입의 속성 키는 모두 K타입, 속성값은 모두 T 타입

```tsx
interface IndexSignatureEx {
	[key： string]： number;
}
```

인덱스 시그니처를 선언할 때 다른 속성을 추가로 명시해줄 수 있는데 이때 추가로 명시된 속성은 인덱스 시그니처에 포함되는 타입이어야 한다.

```tsx
interface IndexSignatureEx2 {
	[key： string]： number ； boolean;
	length: number;
	isValid： boolean;
	name： string; // 에러 발생
}
```

### 인덱스드 엑세스 타입**(Indexed Access Types)**

다른 타입의 특정 속성이 가지는 타입을 조회하기 위해서 사용

```tsx
type Example = {
	a: number;
	b: string;
	c: boolean;
}；
//Example 타입의 a 속성이 가지는 타입을 조회하기 위한 인덱스드 엑세스 타입
type IndexedAccess = Example["a"];
type IndexedAccess2 = Example["a" | "b"]; // number | string
type IndexedAccess3 = Example[keyof Example]; // number | string | boolean

type ExAlias = "b" ； "c";
type IndexedAccess4 = Example[ExAlias]; // string | boolean
```

### 맵드타입**(Mapped Types)**

다른 타입을 기반으로 한 타입을 선언할 때 사용. 반복적인 타입 선언을 할 때 좋다.

```tsx
type Example = {
	a: number;
	b: string;
	c: boolean;
};

type Subset<T> = {
	[K in keyof T]?: T[K];
}；

const aExample： Subset<Example> = { a： 3 };
const bExample： Subset<Example> = { b： "hello" };
const acExample： Subset<Example> = { a： 4, c： true };
```

`readonly`와 `?`를 수식어로 적용할 수 있다. `readonly`는 읽기 전용으로 만들고 싶을 때 붙여주는 수식어이고, `?`는 선택적 매개변수(옵셔널 파라미터)로 만들고 싶을 때 붙여주는 수식어다.

기존 타입에 존재하던 `readonly`와 `?`앞에 `-`를 붙여주면 반대로 제거할 수도 있다.

```tsx
type ReadOnlyEx = {
	readonly a： number;
	readonly b： string;
}；

type CreateMutable<Type> = {
	-readonly [Property in keyof Type]： Type[Property];
}；

type ResultType = CreateM니table<ReadOnlyEx>; // { a： number; b： string }
```

배민에서 맵드타입으로 불필요한 반복 없이 효율적으로 타입을 선언한 사례

```tsx
const BottomSheetMap = {
	//...
}；

export type BOTTOM_SHEET_ID = keyof typeof BottomSheetMap;

// 불필요한 반복이 발생한다
type BottomSheetStore = {
	RECENT_CONTACTS: {
		resolver?： (payload： any) => void;
		args?： any;
		isOpened： boolean;
	}；
	CARD_SELECT: {
		resolver?： (payload： any) => void;
		args?： any;
		isOpened： boolean;
	}；
	SORT_FILTER: {
		resolver?： (payload： any) => void;
		args?： any;
		isOpened： boolean;
	}；
	// ...
}；

// Mapped Types를 통해 효율적으로 타입을 선언할 수 있다
type BottomSheetStore = {
	[index in BOTTOM_SHEET_ID]: {
		resolver?： (payload： any) => void;
		args?： any;
		isOpened： boolean;
	}；
｝；
```

### 템플릿 리터럴 타입**(TemPlate Literal Types)**

Js의 템플릿 리터럴 문자열을 사용해서, 문자열 리터럴 타입을 선언할 수 있는 문법

```tsx
type Stage =
	| "init"
	| "select-image"
	| "edit-image"
	| "decorate-card"
	| "capture-image";
type StageName = '${Stage}-stage';
// 'init-stage'|'select-image-stage'|'edit-image-stage'|'decorate-card-stage'|'capture-image-stage'
```

### 제네릭(Generic)

다양한 타입 간의 재사용성을 높이기 위해 사용하는 문법. 

함수, 타입, 클래스 등에서 내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를 사용해서 비워둔 다음, 외부에서 타입을 지정해서 사용하는 방식.

```tsx
// 타입 변수명으로는 T(type), E(Element), K(Key), V(Value) 등 한 글자로 된 이름을 주로 사용
type ExampleArrayType<T> = T[];
const array： ExampleArrayType<string> = ["치킨", "피자", "우동"]

// 제네릭 함수 호출 시 컴파일러가 타입 추론이 가능하면 반드시 <>안에 타입을 명시할 필요는 없다. 
function exampleFunc<T>(arg： T)： T[] {
	return new Array(3).fill(arg);
}
exampleFunc("hello"); // T는 string으로 추론

// 제네릭 타입에 기본값을 추가할 수도 있다.
interface SubmitEvent<T = HTMLElement> extends SyntheticEvent<T> { submitter: T; }
```

제네릭은 일반화된 데이터 타입을 의미한다. 그렇기에 함수나 클래스 등의 내부에서 제네릭을 사용할 때 어떤 타입이든 될 수 있다는 개념을 알고 있어야 한다. 특정한 타입에서만 존재하는 멤버를 참조하려고 하면 안된다.

```tsx
function exampleFunc2<T>(arg： T)： number {
	return arg.length; // 에러 발생: Property 'length' does not exist on type 'T'
}

// length 속성을 가진 타입만 받도록 하면 가능하다.
interface TypeWithLength {
	length： number;
}

function exampleFunc3<T extends TypeWithLength>（arg： T）： number {
	return arg.length;
}
```

파일 확장자가 tsx일 때 화살표 함수에 제네릭을 사용하면 제네릭의 꺾쇠괄호와 태그의 꺾쇠갈호를 혼동해서 에러가 발생할 수 있다. 그러니까 걍 function으로 선언해라.