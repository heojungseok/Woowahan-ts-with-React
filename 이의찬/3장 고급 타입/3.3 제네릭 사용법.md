## 3.3 제네릭 사용법

### 함수의 제네릭

함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 제네릭을 사용

### 호출 시그니처의 제네릭

호출 시그니처: 함수의 매개변수와 반환타입을 미리 선언하는 것

### 제네릭 클래스

외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스

### 제한된 제네릭

타입 매개변수에 대한 제약 조건을 설정하는 기능. 타입 매개변수가 특정 타입을 상속하면 그 타입으로 제약된다.

```tsx
type ExtendsString<Key extends string> = { }
```

기본 타입뿐만 아니라 유니온 타입, 인터페이스, 클래스도 사용할 수 있다.

### 확장된 제네릭

제네릭은 여러 타입을 상속 가능하며, 타입 매개변수를 여러 개 둘 수도 있다.

### 제네릭 예시

제네릭의 장점은 다양한 타입을 받게 함으로써 코드를 효율적으로 재사용할 수 있는 것

실제 현업에서는 API 응답 값의 타입을 지정할 때 주로 사용된다.

```tsx
export interface MobileApiResponse<Data> {
	data： Data;
	statusCode： string;
	statusMessage?： string;
}

// 다양한 응답 값의 타입에 MobileApiResponse를 활용해서 코드를 효율적으로 재사용
export const fetchPricelnfo = ()： Promise<MobileApiResponse<PriceInfo» => {
	const priceUrl = "https： ―// url 주소
	
	return request({
		method: "GET",
		url： priceUrl,
}；

export const fetchOrderlnfo = ()： Promise<MobileApiResponse<Order» => {
	const orderUrl = "https： —// url 주소
	
	return request({
		method: "GET",
		url： orderUrl,
	});
};
```

### 제네릭 안티패턴

1. 굳이 사용하지 않아도 될 때
    
    ```tsx
    type GType<T> = T;
    type RequirementType = "USE" | "UN_USE" | "NON_SELECT";
    interface Order {
    	// 만약 GType이 여기서만 사용된다면?
    	getRequirement()： GType<RequirementType>;
    }
    
    // 이거랑 위의 코드는 다를바가 없다. 타입 매개변수를 그대로 선언하는 것과 동일하다.
    interface Order {
    	getRequirement()： RequirementType;
    }
    ```
    
2. `any`를 사용할 때
    
    `any`를 사용하면 type을 쓰는 의미가 없어진다. Js로 하는거랑 똑같다.
    
3. 가독성을 고려하지 않은 사용
    
    제네릭은 과하게 사용되면 가독성을 해치고, 타입을 이해하기 어려워진다. 부득이한 상황이 아니라면 의미 단위로 분할해서 사용하는 것이 좋다.