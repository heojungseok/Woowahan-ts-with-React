## 1. 조건부 타입

타입도 조건에 따라 다른 타입을 반환해야 할 때가 있다. 타입스크립트의 조건부 타입은 삼항 연산자와 동일하게 `Condition ? A : B` 형태를 가진다. Condition이 `true`일 때 A, `false`일 때 B가 도출된다.

조건부 타입을 활용하면 중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있어 더욱 정확한 타입 추론이 가능해진다.

### **extends**와 제네릭을 활용한 조건부 타입

```tsx
// 타입 T를 U에 할당할 수 있으면 X 타입, 아니면 Y 타입
T extends U ? X : Y
```

```tsx
interface Bank {
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  financialCode: string;
  companyName: string;
  name: string;
  appCardType?: string;
}

// T를 card에 할당할 수 있으면 Card 타입, 아니면 Bank 타입
type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;  // Card
type BankPayMethodType = PayMethod<"bank">;  // Bank
```

> 와 근데 진짜 말도안되게 정교하게 짜네? 전 이런거 생각도 못해봄;;
**이 값이 들어오면 이 타입, 저 값이 들어오면 저 타입"을 자동으로 처리**해주는 타입 시스템
> 

**클로드의 예시**

```tsx
type ApiResponse<T extends "success" | "error"> = 
  T extends "success" 
    ? { data: any; status: 200 }
    : { error: string; status: 400 };

function handleResponse<T extends "success" | "error">(
  type: T
): ApiResponse<T> {
  // type이 "success"면 자동으로 성공 타입
  // type이 "error"면 자동으로 에러 타입 반환
}
```

### 조건부 타입을 사용하지 많았을 때의 문제점

react-query를 활용한 예시로 살펴보자. 계좌, 카드, 앱 카드 등 3가지 결제 수단 정보를 가져오는 API가 있다.

```tsx
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;
  // ...
  return result;
};
```

이 함수는 타입으로 "card", "appcard", "bank"를 받아서 해당 결제 수단의 정보 리스트를 반환한다. 하지만 반환하는 Data 타입이 `PayMethodInfo<Card> | PayMethodInfo<Bank>`이기 때문에, 사용자가 "card"를 넣어도 타입스크립트는 정확한 타입을 추론할 수 없다.

```tsx
const { data: pocketList } = useGetRegisteredList("card");
// pocketList: PayMethodInfo<Card>[] | PayMethodInfo<Bank>[] | undefined
```

인자로 넣는 타입에 알맞은 타입을 반환하고 싶지만, 타입 설정이 유니온으로만 되어있기 때문에 타입스크립트는 해당 타입에 맞는 Data 타입을 추론할 수 없다.

> 예시 너무 어려움… 클로드한테 물어봄..
> 

```tsx
// 개선 전: 항상 유니온 타입 반환(extends 사용하지 않을 경우)
function getData(type: "user" | "post"): User | Post {
  // ...
}
const result = getData("user"); // User | Post (불명확)
```

```tsx
// 개선 후: 조건부 타입으로 정확한 타입 반환
type DataType<T> = T extends "user" ? User : Post;

function getData<T extends "user" | "post">(type: T): DataType<T> {
  // ...
}
const result = getData("user"); // User (정확함) ✅
```

### **extends** 조건부 타입을 활용하여 개선하기

조건부 타입을 사용해서 PayMethodType 타입을 개선해보자.

```tsx
type PayMethodType<T extends "card" | "appcard" | "bank"> = 
  T extends "card" | "appcard" 
    ? Card 
    : Bank;
```

PayMethodType의 제네릭으로 받은 값이 "card" 또는 "appcard"일 때는 `PayMethodInfo<Card>` 타입을, 아닐 때는 `PayMethodInfo<Bank>` 타입을 반환하도록 수정했다.

```tsx
export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<PayMethodType<T>[]> => {
  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;
  // ...
  return result;
};
```

이제 인자로 "card" 또는 "appcard"를 넣으면 `PocketInfo<Card>`를 반환하고, "bank"를 넣으면 `PocketInfo<Bank>`를 반환한다. 사용자는 불필요한 타입 가드를 하지 않아도 되고, 타입 단언도 필요 없다.

```tsx
const { data: pocketList } = useGetRegisteredList("card");
// pocketList: PocketInfo<Card>[] | undefined ✅
```

> extends 활용 정리
> 
- **제네릭과 extends를 함께 사용**해 제네릭으로 받는 타입을 제한 → 잘못된 값을 넘길 수 없어 휴먼 에러 방지
- **extends를 활용해 조건부 타입 설정** → 반환 값을 사용자가 원하는 값으로 구체화 → 불필요한 타입 가드, 타입 단언 방지

### **infer**를 활용해서 타입 추론하기

infer는 타입을 추론하는 역할을 한다. 삼항 연산자를 사용한 조건문의 형태를 가지며, extends로 조건을 서술하고 infer로 타입을 추론한다.

```tsx
// T extends Box<infer Gift> : T가 상자(Box)인지 확인
// infer Gift : 상자면 안에 선물이 뭔지 확인해서 Gift에 저장
// ? Gift : 상자면 선물(Gift) 꺼내줌
// T : 상자 아니면 그냥 그대로
type UnpackBox<T> = T extends Box<infer Gift> ? Gift : T;

type MyBox = Box<"인형">;
type Present = UnpackBox<MyBox>;  // "인형" (상자 벗겨짐)

type NotBox = "사탕";
type Item = UnpackBox<NotBox>;    // "사탕" (원래 그대로)
```

```tsx
// getUser의 반환 타입은 Promise<{ name: string, age: number }>
// Promise 안에 있는 실제 데이터 타입만 꺼내고 싶다면?
async function getUser() {
  return { name: "철수", age: 20 };
}

// "Promise면, 안에 있는 타입을 K로 꺼내줘"
type UnpackPromise<T> = T extends Promise<infer K> ? K : T;

type UserPromise = ReturnType<typeof getUser>;  
// Promise<{ name: string, age: number }>

type User = UnpackPromise<UserPromise>;         
// { name: string, age: number } ✅ (Promise 벗겨짐!)
```