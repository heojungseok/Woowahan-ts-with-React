## 3. 커스텀 유틸리티 타입 활용하기

타입스크립트에서 제공하는 유틸리티 타입만으로는 표현하는 데 한계를 느끼기도 한다. 이럴 때는 유틸리티 타입을 활용한 커스텀 유틸리티 타입을 제작해서 사용하면 된다.

### 유틸리티 함수를 활용해 **styled-components**의 중복 타입 선언 피하기

컴포넌트의 Props와 styled-components의 타입이 동일할 때 Pick 유틸리티 타입을 활용하면 중복을 제거할 수 있다.

```tsx
// Props 타입
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
};

// Pick을 사용한 styled-components 타입
type StyledProps = Pick<Props, "height" | "color" | "isFull">;
const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) => height || "10px"};
  background-color: ${({ color }) => colors[color || "gray7"]};
  // ...
`;
```

### **PickOne** 유틸리티 함수

여러 속성 중 하나의 속성만 받고 싶을 때 사용하는 커스텀 유틸리티 타입

```tsx
type Card = { card: string };
type Account = { account: string };

function withdraw(type: Card | Account) {}

// 문제: 둘 다 받아도 에러가 발생하지 않음
withdraw({ card: "hyundai", account: "hana" }); // 에러가 발생해야 하는데 안 남!
```

유니온 타입은 합집합이기 때문에 card, account 속성이 모두 포함되어도 타입 에러가 발생하지 않는다.
**해결 방법 1: 식별할 수 있는 유니온**

```tsx
type Card = {
  type: "card";
  card: string;
};
type Account = {
  type: "account";
  account: string;
};

function withdraw(type: Card | Account) {}

withdraw({ type: "card", card: "hyundai" }); // OK
```

but, 일일이 `type` 속성을 추가해야 하는 불편함이 있다.

**해결 방법 2: PickOne 커스텀 유틸리티 타입**

```tsx
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
```

**PickOne의 작동 원리:**

1. 선택한 속성은 필수값으로 설정
2. 나머지 속성은 옵셔널 + undefined로 설정

```tsx
type Card = { card: string };
type Account = { account: string };
type CardOrAccount = PickOne<Card & Account>;

function withdraw(type: CardOrAccount) {}

withdraw({ card: "hyundai" }); // OK
withdraw({ account: "hana" }); // OK
withdraw({ card: "hyundai", account: "hana" }); // 에러 발생!
```

### **NonNullable** 타입 검사 함수를 사용하여 간편하게 타입 가드하기

`NonNullable` 유틸리티 타입과 `is` 키워드를 사용해 null 검사 함수를 만들 수 있다.

NonNullable 타입은 제네릭으로 받는 T가 null 또는 undefined일 때 never를, 아니면 T를 반환하는 타입

```tsx
type NonNullable<T> = T extends null | undefined ? never : T;
```

**NonNullable 검사 함수**

```tsx
function NonNullable<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}
```

**Promise.all과 함께 사용하기**

```tsx
const shopAdCampaignList = await Promise.all(
  shopList.map((shop) => AdCampaignAPI.operating(shop.shopNo))
);
// 타입: Array<AdCampaign[] | null>

// NonNullable로 필터링
const shopAds = shopAdCampaignList.filter(NonNullable);
// 타입: Array<AdCampaign[]>
```

단순히 `!!shop`으로 필터링하면 타입이 좁혀지지 않지만, `NonNullable` 함수를 사용하면 타입스크립트가 null이 제거되었음을 인식