## **JSX로** 구현된 **Select** 컴포넌트

### 기본 타입 정의

```tsx
type Option = Record<string, string>;

interface SelectProps {
  options: Option;
  selectedOption?: string;
  onChange?: (selected?: string) => void;
}

const Select = ({ options, selectedOption, onChange }: SelectProps): JSX.Element => {
  *// ...*
};
```

### 리액트 이벤트 핸들러 타입

리액트는 브라우저 이벤트를 합성한 합성 이벤트(SyntheticEvent)를 제공한다

```tsx
const Select = ({ onChange, options, selectedOption }: SelectProps) => {
  const handleChange: React.ChangeEventHandler<HTMLSelectElement> = (e) => {
    const selected = Object.entries(options).find(
      ([_, value]) => value === e.target.value
    )?.[0];
    onChange?.(selected);
  };

  return <select onChange={handleChange}>{*/* ... */*}</select>;
};
```

### useState에 타입 추가

제네릭 타입을 명시하지 않으면 초깃값의 타입을 기반으로 추론한다

```tsx
const fruits = {
  apple: "사과",
  banana: "바나나",
  blueberry: "블루베리",
};

type Fruit = keyof typeof fruits;

const FruitSelect = () => {
  const [fruit, changeFruit] = useState<Fruit | undefined>();
  
  return <Select onChange={changeFruit} options={fruits} selectedOption={fruit} />;
};
```

`keyof typeof` 패턴을 사용하면 객체의 키값을 유니온 타입으로 추출할 수 있다.

### 제네릭 컴포넌트 만들기

객체의 키값만 전달받도록 제한하려면 제네릭을 사용한다

```tsx
interface SelectProps<OptionType extends Record<string, string>> {
  options: OptionType;
  selectedOption?: keyof OptionType;
  onChange?: (selected?: keyof OptionType) => void;
}

const Select = <OptionType extends Record<string, string>>({
  options,
  selectedOption,
  onChange,
}: SelectProps<OptionType>) => {
  *// ...*
};
```

이렇게 하면 `selectedOption`에 잘못된 값을 전달할 때 타입 에러가 발생한다.

### HTML 속성 추가하기

`Pick`이나 인덱스 접근을 활용해 필요한 HTML 속성을 추가할 수 있다

```tsx
type ReactSelectProps = React.ComponentPropsWithoutRef<"select">;

interface SelectProps<OptionType extends Record<string, string>>
  extends Pick<ReactSelectProps, "id" | "className"> {
  options: OptionType;
  selectedOption?: keyof OptionType;
  onChange?: (selected?: keyof OptionType) => void;
}
```

### styled-components로 스타일 적용

먼저 theme 객체와 타입을 정의한다:

```tsx
const theme = {
  fontSize: {
    default: "16px",
    small: "14px",
    large: "18px",
  },
  color: {
    white: "#FFFFFF",
    black: "#000000",
  },
};

type Theme = typeof theme;
type FontSize = keyof Theme['fontSize'];
type Color = keyof Theme['color'];
```

스타일 props를 정의하고 `Partial`로 옵셔널하게 만든다:

```tsx
interface SelectStyleProps {
  color: Color;
  fontSize: FontSize;
}

const StyledSelect = styled.select<SelectStyleProps>`
  color: ${({ color }) => theme.color[color]};
  font-size: ${({ fontSize }) => theme.fontSize[fontSize]};
`;

interface SelectProps<OptionType extends Record<string, string>>
  extends Partial<SelectStyleProps> {
  *// ...*
}
```

## 공변성과 반공변성

객체의 메서드 타입을 정의하는 방법은 두 가지가 있고, 미묘한 차이가 있다:

```tsx
interface Props<T extends string> {
  onChangeA?: (selected: T) => void;  *// 반공변성*
  onChangeB?(selected: T): void;       *// 이변성*
}
```

**공변성**: 타입 A가 B의 서브타입일 때, `T<A>`가 `T<B>`의 서브타입이 되는 성질

**반공변성**: 타입 A가 B의 서브타입일 때, `T<B>`가 `T<A>`의 서브타입이 되는 성질

함수 타입을 화살표 표기법으로 작성하면 반공변성을 띠게 되고, 일반 메서드 표기법으로 작성하면 이변성(공변성 + 반공변성)을 띠게 된다. 안전한 타입 가드를 위해서는 반공변적인 함수 타입을 설정하는 것이 권장된다.