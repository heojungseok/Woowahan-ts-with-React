### 클래스 컴포넌트 타입

클래스 컴포넌트는 `React.Component`나 `React.PureComponent`를 상속받는다. 이 두 타입은 제네릭으로 props와 state 타입을 받는다.

```tsx
interface WelcomeProps {
  name: string;
}

class Welcome extends React.Component<WelcomeProps> {
  */* ... */*
}
```

### 함수 컴포넌트 타입

함수 컴포넌트를 선언하는 방법은 여러 가지다.

```tsx
*// 함수 선언*
function Welcome(props: WelcomeProps): JSX.Element {}

*// React.FC 사용*
const Welcome: React.FC<WelcomeProps> = ({ name }) => {};

*// React.VFC 사용*
const Welcome: React.VFC<WelcomeProps> = ({ name }) => {};

*// 반환 타입 직접 지정*
const Welcome = ({ name }: WelcomeProps): JSX.Element => {};
```

`React.FC`와 `React.VFC`의 차이는 children 타입을 암묵적으로 포함하는지 여부다. `React.FC`는 children을 자동으로 포함하지만, `React.VFC`는 포함하지 않는다. 리액트 v18부터는 `React.VFC`가 삭제되고 `React.FC`에서 children이 제거되었다.

### Children props 타입 지정

가장 보편적인 children 타입은 `ReactNode | undefined`다. 더 구체적으로 타입을 지정하고 싶다면

```tsx
// 특정 문자열만 허용
type WelcomeProps = {
  children: "천생연분" | "더 귀한 분" | "귀한 분" | "고마운 분";
};

// 모든 문자열 허용
type WelcomeProps = {
  children: string;
};

// ReactElement만 허용
type WelcomeProps = {
  children: ReactElement;
};`
```

## 렌더링 관련 타입들

### ReactElement vs JSX.Element vs ReactNode

**ReactElement**는 `React.createElement`의 반환 타입으로, 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷이다

```tsx
interface ReactElement<P = any, T extends string | JSXElementConstructor<any> = ...> {
  type: T;
  props: P;
  key: Key | null;
}
```

**JSX.Element**는 ReactElement를 확장한 타입으로, 글로벌 네임스페이스에 정의되어 있다

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

**ReactNode**는 ReactElement보다 훨씬 넓은 범위의 타입으로, 리액트의 render 함수가 반환할 수 있는 모든 형태를 담고 있다:

```tsx
type ReactNode =
  | ReactChild
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined;
```

포함 관계: ReactNode > ReactElement > JSX.Element

### 각 타입의 사용 예시

**ReactNode**: children prop처럼 다양한 타입을 허용하고 싶을 때 사용

```tsx
interface MyComponentProps {
  children?: React.ReactNode;
}
```

**JSX.Element**: render props 패턴으로 리액트 엘리먼트를 전달할 때 사용

```tsx
interface Props {
  icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
  const iconSize = icon.props.size;
  return <li>{icon}</li>;
};
```

**ReactElement**: 제네릭으로 props 타입을 명시해서 더 정확한 추론이 필요할 때 사용

```tsx
interface IconProps {
  size: number;
}

interface Props {
  icon: React.ReactElement<IconProps>;
}

const Item = ({ icon }: Props) => {
  const iconSize = icon.props.size; *// size가 자동 완성됨*
  return <li>{icon}</li>;
};
```

## HTML 요소 타입 활용하기

### DetailedHTMLProps와 ComponentPropsWithoutRef

HTML 태그의 속성을 활용하는 방법은 크게 두 가지

```tsx
*// DetailedHTMLProps 사용*
type NativeButtonProps = React.DetailedHTMLProps
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>;

type ButtonProps = {
  onClick?: NativeButtonProps["onClick"];
};

*// ComponentPropsWithoutRef 사용*
type NativeButtonType = React.ComponentPropsWithoutRef<"button">;

type ButtonProps = {
  onClick?: NativeButtonType["onClick"];
};
```

### ref를 다루는 올바른 방법

함수 컴포넌트에서 ref를 전달받으려면 `forwardRef`를 사용해야 한다

```tsx
const Button = forwardRef<HTMLButtonElement, NativeButtonType>((props, ref) => {
  return <button ref={ref} {...props}>버튼</button>;
});
```

이때 props 타입으로는 `ComponentPropsWithoutRef`를 사용하는 것이 안전하다. `DetailedHTMLProps`처럼 ref를 포함하는 타입을 사용하면, 실제로는 동작하지 않는 ref를 받도록 타입이 지정되어 예기치 않은 에러가 발생할 수 있다.