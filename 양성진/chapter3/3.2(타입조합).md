## 교차 타입

#### 특징:

여러가지 타입을 결합하여 하나의 단일 타입으로 만들수 있다.
-   기존의 존재하는 다른 타입들을 합쳐서 해당 타입의 모든 멤버를 가지는 새로운 타입을 생성하는것.
- 교차타입은 &을 이용해서 표기함.

```ts
type ProductItem{
    id:number;
    name:string;
    type:string;
}

type ProductItemWithDiscount = ProductItem & {discount:number;}
```

## 유니온 타입

#### 특징
교차 타입은 (A&B)는 타입 둘다를 만족하는 경우라면, 유니온타입은 A 또는 B타입중 하나가 될수 있는 타입을 말하며
A|B같이 표기한다.

```ts
type ProductItem{
    id:number;
    name:string;
    type:string;
    quantity:number;
}
type CardItem {
    id:number;
    name: string;
    imageUrl:string
}

type ProductionEventItem = ProductItem | CardItem


const printPromotionItem = (item:PromotionEventItem) => {
    console.log(name) // OK
    console.log(item.quantity); // Error
}
```
에러가 나는건 함수 내부서 quantity를 참조하려 시도하면, 컴파일 에러가 발생함. quantity는 ProductItem에만 존재함. 
CartItem은 quantity가 없기에 PromotionEventItem에서는 참조가 불가능함. 



## 인덱스 시그니처

```ts
interface IndexSignature{
    [key:string]: number|boolean;
    length:number;
    name:string// Error
}
```
[key: K] : T꼴로 명시함. 속성키는 모두 K타입이여야 하고, 속성값은 모두 T 타입을 가져야함.
그래서 name의 스트링은 에러가 남.

## 인덱스드 엑세스 타입 

인덱스드 엑세스타입은 다른타입의 특정 속성이 가지는 타입을 조회하기 위해 사용.

```ts

type Example {
    a:number;
    b:string;
    c:boolean;
}

type IndexAccess = Example['a'];
type IndexAccess2 = Example['a'|'b']; // number | string;
type IndexAccess3 = Example[keyof Example]; // number |string | boolean;

type ExAlias = "b" | "c";
type IndexAccess4 =Example[ExAlias]; // string | boolean

```

- 유니온 타입, keyof, 타입별칭 등의 표현을 사용할 수 있음.
- 배열의 요소 타입을 조회하기 위해 인덱스드 엑세스 타입을 사용하는 경우가 있다.


## 맵드 타입

## 템플릿 리터럴 타입



