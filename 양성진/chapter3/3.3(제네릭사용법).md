## 제네릭

```ts
type ExampleArrayType<T> = T[];

const stringArray:ExampleArrayType<string> = ['가','나','다']

```
사전적으로는 일반적인것,타입스크립트에서는 일반화된 데이터 타입을 뜻함.

내부적으로 사용할 타입을 정해두지 않고, 타입 변수를 사용해서, 실제로 사용시 그 값을 외부에서 타입변수자리에 지정하여 사용하는 방식.

여러타입에 대해 따로 입력할 필요가 없어서 재사용성이 크게 향상됨.


특정타입에서만 존재하는 멤버를 참조할수 없음.

없는 속성을 가져다 쓸수 없기때문에

```ts
function sampleFn1<T>(arg:T)T[]{
return arg.length // Error: 획일화된 타입. 제네릭 T에 length라는게 있는지 모르니까 사용할수 없음.
}
```

```ts
interface lengthType {
    length:number;
}
function sampleFn1<T extends lengthType>(arg:T)T[]{
return arg.length // length가 있는지 확인이 되니까 사용이 가능함.
}
```

### 주의할점.

파일 확장자가 tsx일때, 화살표 함수에 제네릭을 사용하면 에러가 발생함.

```tsx
const arrowFunction = <T>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Error JSX element 'T' has no corresponding closing tag
};

const arrowFunction = <T extends {}>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Ok
}

```

tsx는 타입스크립트 + JSX이므로 제네릭의 꺽쇠 괄호와 태그의 꺽쇠괄호를 혼동해서 문제가 생김.


## 제네릭 사용법

다양한 곳에서 사용할 수 있다.

### 1. 함수 제네릭

```ts
const arrowFunction = <T extends {}>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Ok
}
```

매개 변수나 반환값에 다양한 타입을 넣고 싶을때 사용할 수 있다.

### 2. 호출 시그니처 제네릭

함수타입 문법으로, 매개변수와 반환 타입을 미리 선언하는것을 말함.

```ts
interface CallSignature<T> {
    getData: (id: string) => Promise<T>;  // T를 반환하도록 미리 선언
    processItem: (item: T) => T;          // T를 받아 T를 반환하도록 미리 선언
}

```

 
### 3. 제한된 제네릭

타입 매개변수에 제약조건을 거는 기능을 말함.

```ts
type 스트링만제약을거는타입<Key extends string> = {
  [K in Key]: string;
};

// 사용 예시
type UserFields = 스트링만제약을거는타입<"name" | "email" | "phone">;
// 결과: { name: string; email: string; phone: string; }

```

이처럼 타입 매개변수가 특정 타입으로 묶였을때, **키를 바운드 타입 매개변수라** 부름.
string을 **키의 상한 한계**라고 함.


### 4. 확장된 제네릭

여러 타입을 상속받을수 있으며, 타입 매개변수를 여러개 둘 수도 있다.

```ts
<key extends string>
```
이런 식으로 제약하면, 제네릭의 유연성을 잃어버림

```ts
<key extends string | number>
```

이럴땐 유니온 타입을 상속해서 선언하면 됨.

하지만 타입 매개변수가 여러개일때는 처리할수 없음.

이럴때는 매개변수를 하나 더 추가하여 선언한다.

```ts
// 여러 타입 매개변수 사용, 일부에만 제약 조건
function createRecord<T, U extends string>(data: T, key: U): Record<U, T> {
  return { [key]: data } as Record<U, T>;
}

// 사용 예시
const userRecord = createRecord(123, "userId");     // Record<"userId", number>
const nameRecord = createRecord("홍길동", "name");   // Record<"name", string>

```


### 5. 제네릭 사용 예시 및 주의점

API응답값으로 주로 사용을 많이 하는편,
우아한형제들에서는 API응답값을 주지정할떄 주로 제네릭을 사용해서 코드의 재사용성을 높이고, 적절한 타입추론을 한다고 합니다.

너무 오남용하면 코드의 가독성을 해치는 경우도 있으니 주의해서 사용해야함.

책에서는 주로 사용하지 않아도 되는 케이스를 설명함.

1. 굳이 목적의 의미를 정확히 담고 있지 않지만 사용하게 되는 경우, 직접적으로 선언해도 무방할경우.
- 예시를 보고 생각한대로 적어봤습니다.

2. 제네릭에 any사용하기

3. 가독성을 고려하지 않는 사용
- 부득이한 상황을 빼고는 복잡한 제네릭은 의미단위로 분할해서 사용.