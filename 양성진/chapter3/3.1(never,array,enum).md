## never

**특징:**

- 함수와 관련하여 많이 사용되는 타입.
- 값을 반환할수 없는 타입을 말한다.
  - 에러를 던지는 경우
  - 무한히 함수가 실행되는 경우
- 모든 타입의 하위 타입이다.

  - 자신을 제외한 어떤 타입도 never타입에 할당될 수 없다.
  - any타입이라 할지라도 never타입에 할당될수 없다.

- 엄격한 타입검사 목적으로 never타입을 명시적으로 사용하기도 함.

## Array

### 타입스크립트에서 배열

- 타입스크립트에서는 배열을 객체에 속하는 타입으로 분류함. 단독으로 배열이라는 자료형에 국한시키지 않음.
- 특수한 문법을 함께 다뤄야한다.

Array키워드 외 [] 대괄호를 이용해서 명시할수 있음

```ts
// 숫자에 해당하는 원소만 사용.
let array: number[] = [1, 2, 3];

// 제네릭이란 특수 문법을 사용해서
let array: Array<number> = [1, 2, 3];
```

다양한 자료형의 원소를 함께 다룰 수 있는데, 여러가지 타입을 모두관리하는 경우,
배열을 선언하려면, 유니온 타입을 사용할 수 있다.

```ts
const array1: Array<number | string> = [1, "문자"];
const array2: number[] | string[] = [1, "문자"];

const array3: (number | string)[] = [1, "문자"];
```

배열 타입을 명시하는 것만으로 배열의 길이까지 제한 할순 없음.

- 튜플은 배열타입의 하위타입으로 기존 타입스크립트의 배열기능에 길이제할까지 추가한 타입시스템이라 볼수 있음.

### 튜플

- 타입스크립트의 타입 시스템과 대괄호를 사용해서 선언할수 있다.

```tsx
let tuple: [number] = [1];
tuple = [1, 2]; //(O)
tuple = [1, "string"]; //(x)

// 여러 타입과 혼합이 가능.
let tuple: [string, number, boolean] = [1, "문자", true];
```

- 타입스크립트에서의 배열과 튜플은 제한적으로 쓰인다.

  - 배열은 허용하지 않는 타입이 서로 섞이는 것을 방지하며, 타입 안전성을 제공함.
  - 튜플은 길이까지 제한하여ㅡ 원소 개수와 타입을 보장함. 컨벤션을 잘 지키고 배열의 원소의 명확한 의미와 쓰임새를 보장할때, 안전하게 사용할수 있는 타입.

useState는 반환값이 명확하고 잘설계된 api이기 때문에 튜플 타입을 통해서 이와같은 유연성을 얻을 수 있음.

```js
const [value, setValue] = useState(false);
const [username, setUsername] = useState("");
const [count, setCount] = useState(0);
```

- 첫번째 원소와 두번째 원소의 타입과 의미는 명확하기 때문에 그에 맞게 사용자가 입력하면됨.

## Enum

- 일종의 구조체를 만드는 타입시스템.

enum을 사용해서 열거형을 정의할수 있다.

- 열거형은 각각의 멤버를 가지고 있다. 명명한 각 멤버는 값을 스스로 추론한다.

```ts
enum ProgrammingLanguage {
  Typescript, // 0
  Javascript, // 1
  Java, // 2
  Python, // 3
  Kotlin, // 4
  Rust, // 5
  Go, // 6
}
// 각 멤버에게 접근하는 방식은 자바스크립트에서 객체의 속성에 접근하는 방식과 동일하다
ProgrammingLanguage.Typescript; // 0
ProgrammingLanguage.Rust; // 5
ProgrammingLanguage["Go"];
// 6
// 또한 역방향으로도 접근이 가능하다
ProgrammingLanguage[2]; // "Java"
```

- 모든 멤버에게 일일이 값을 할당도 가능하지만, 그렇게 하지 않앋고됨.
- 이전 멤버값의 숫자를 기준으로 1씩 늘려가며 자동으로 할당.

```ts
enum ProgrammingLanguage {
  Typescript = "Typescript",
  Javascript = "Javascript",
  Java = 300,
  Python = 400,
  Kotlin, // 401
  Rust, // 402
  Go, // 403
}
```

- 주로 문자열 상수를 생성하는데 사용된다.

- 열거형은 그 자체로 변수 타입으로 지정할 수 있다.
- 열거형이 가지는 모든 멤버를 값으로 받을 수 있다.
  - 이런 특성은 가독성을 높여준다.

```ts
enum ItemStatusType {
DELIVERY.HOLD = "DELIVERY_HOLD", // 배송 보류
DELIVERY_READY = "DELIVERY_READY", // 배송 준비 중
DELIVERING = "DELIVERING"
, // 배송 중
DELIVERED = "DELIVERED", // 배송 완료
}

const checkltemAvailable = (itemstatus： ItemStatusType) => {
switch (itemStatus) {
  case ItemStatusType.DELIVERY_HOLD:
  case ItemStatusType.DELIVERY_READY:
  case ItemStatusType.DELIVERING：
    return false;
  case ItemStatusType.DELIVERED:
  default：
    return true;
}
};
```

- itemStatus의 타입이 문자열로 지정된 경우와 비교했을떄
  - 타입 안정성: 명시되지 않는 문자열 외에 들어올수 없음.
  - 높은 응집력과 명확한 의미전달: 다루는 값이 무엇인지 명확하다. 그리고 아이템 상태에 대한값을 모아놓은것으로 응집력이 뛰어나다.
  - 가독성: 응집도가 높아서 말하고자 하는 바가 명확하다.

### 주의점

- 숫자로만 이루어져있거나 자동으로 추론된건 안전하지 않는 결과를 초래할수 있음.
  - 역방향으로 접근할때, 타입스크립트는 막지 않음.
  - 이러한 동작을 막기 위해선 const enum으로 열거형을 선언하는 방법이 존재.
  - 하지만 const enum으로 선언해도 숫자 상수로 관리되는 열거형은 접근할때 이를 방해하지 못함.
- 열거형은 타입공간과 값공간에서 모두 사용된다.
