## 컴파일타임과 런타임

- 컴파일 타임 : 소스코드를 기계어 코드로 변환시켜 실행이 가능한 프로그램이 되는 단계
- 런타임: 컴파일이 완료되면 프로그램이 메모리에 적재되어 실행되는데 이 시간을 런타임이라 부름.
- 자바스크립트는 런타임에 에러 발견, 타입스크립트는 컴파일타임에 에러 발견.

## 자바스크립트의 런타임

### 자바스크립트 런타임이란

- 자바스크립트 런타임: 자바스크립트가 실행되는 환경을 의미.
    - 크롬,사파리,Node.js 등이 있다.
- 구성요소 :
    - 자바스크립트 엔진
    - 웹 API
    - 콜백 큐
    - 이벤트 루프
    - 렌더 큐

### 타입스크립트의 컴파일

- 타입스크립트는 tsc라는 컴파일러를 통해 자바스크립트 코드로 변환.
- 고수준 언어가 또 다른 고수준 언어로 변환되는것.
    - 그래서 트랜스파일이라고 부름 컴파일이 아니라.
    - 변환과정 : 소스코드 → 다른 소스코드
        - 그래서 소스 대 소스 컴파일러라 지칭하기도 함.

### 

---

## 타입스크립트 컴파일러(tsc)의 2가지 역할

### 1. 코드 검사기

- 컴파일타임에 타입 오류 검사
- 런타임에서 발생할 수 있는 에러를 사전에 발견
- 예시: `developer.sleep()` → 존재하지 않는 메서드 사전 감지

### 2. 코드 변환기

- 타입스크립트 → 구버전 자바스크립트로 변환 (트랜스파일)
- target 옵션으로 ES5, ES6 등 선택 가능
- 변환 후 타입 정보는 모두 제거됨

---

## 컴파일 5단계 과정

타입스크립트 컴파일러는 타입스크립트 소스코드를 자바스크립트로 변환하며, 이 과정에서 **5단계**를 거쳐 타입 검사와 소스 변환을 진행합니다.

## 컴파일 과정의 5단계

### 1. 프로그램 (Program)

- `tsc` 명령어로 컴파일러가 실행됨
- `tsconfig.json`의 컴파일 옵션을 기반으로 동작
- 프로그램 객체가 생성되어 전체 컴파일 과정을 관리
- 컴파일할 타입스크립트 소스 파일과 임포트된 파일들을 불러옴
- 최초로 불러온 파일을 기준으로 컴파일 시작

### 2. 스캐너 (Scanner)

**역할**: 어휘적 분석(Lexical Analysis)을 통해 토큰 생성

소스코드를 작은 단위로 나누어 의미 있는 토큰으로 변환합니다.

**예시**:

```tsx
const woowa = "bros";
```

**분석 결과**:

- `const` → ConstKeyword
- `woowa` → Identifier
- `=` → EqualsToken
- `"bros"` → StringLiteral
- `;` → SemicolonToken
- (공백) → WhitespaceTrivia

### 3. 파서 (Parser)

**역할**: 토큰 정보를 이용하여 AST(Abstract Syntax Tree) 생성

구문적 분석(Syntax Analysis)을 수행하여 코드의 구조를 트리 형태로 표현합니다.

**AST의 특징**:

- 최상위 노드: 타입스크립트 소스 파일
- 최하위 노드: 파일의 끝 지점(EndOfFileToken)
- 각 노드는 코드상의 위치, 구문 종류, 코드 내용 정보를 포함

**예시**:

```tsx
function normalFunction() {
  console.log("normalFunction");
}
normalFunction();

**AST 구조**:

FunctionDeclaration
  → Identifier: normalFunction
  → Block {...}
    
ExpressionStatement
  → CallExpression
    → PropertyAccessExpression: console.log
      → Identifier: console
      → Identifier: log
    → StringLiteral: 'normalFunction'
```

### 4. 바인더 (Binder)

**역할**: 타입 검사를 위한 심볼(Symbol) 데이터 구조 생성

AST에서 선언된 타입의 노드 정보를 저장하는 심볼을 만들고, 심볼과 AST 노드를 연결합니다.

**심볼 인터페이스**:

```tsx
export interface Symbol {
  flags: SymbolFlags;           *// 심볼 식별자*
  escapedName: string;          *// 심볼 이름*
  declarations?: Declaration[]; *// AST 노드 배열*
}
```

**SymbolFlags 종류**:

- `FunctionScopedVariable`: var 변수나 매개변수
- `BlockScopedVariable`: let, const 변수
- `Property`: 속성이나 enum 멤버
- `Function`: 함수
- `Class`: 클래스
- `Interface`: 인터페이스
- 등등...

**예시**:

```tsx
type SomeType = string | number;        *// → TypeAliasDeclaration*
interface SomeInterface { name: string; } *// → InterfaceDeclaration*
let foo: string = "LET";                *// → VariableDeclaration*
const obj = { name: "이름" };           *// → VariableDeclaration*
class MyClass { ... }                   *// → ClassDeclaration*
```

``

### 5. 체커 (Checker) & 이미터 (Emitter)

**체커**

**역할** : AST와 심볼을 활용하여 타입 검사 수행

- 소스 크기가 약 2.7MB로 매우 큼 (파서는 500KB)
- 타입 검사가 컴파일 과정에서 차지하는 비중이 매우 큼
- AST 노드를 탐색하면서 심볼 정보를 불러와 타입 검사 진행
- `getDiagnostics()` 함수로 타입 검증 및 에러 메시지 저장

**이미터**

**역할 :**

 타입스크립트 소스를 자바스크립트로 변환

- js 파일과 .d.ts 타입 선언 파일 생성
- 타입스크립트 설정 파일 읽기
- 체커를 통해 타입 검증 정보 가져오기
- emitFiles() 함수로 소스 변환 실행

## 전체 컴파일 과정 요약

```markdown

소스코드
   ↓
1. tsc 실행 → 프로그램 객체 생성
   ↓
2. 스캐너 → 토큰 단위 분리
   ↓
3. 파서 → AST 생성
   ↓
4. 바인더 → 심볼 생성 (AST 노드와 연결)
   ↓
5. 체커 → 타입 검사 수행
   ↓
6. 이미터 → 자바스크립트 파일 생성 (에러가 없을 경우)
```