# 상태관리

리액트에서 상태란 렌더링에 영향을 줄수 있는 동적인 데이터 값을 말함.
공식문서의 정의는 이러하다.
- 렌더링 결과에 영향을 주는 정보를 담은 순수 자바스크립트 객체

시간이 지나서 변할 수 있는 동적인 데이터이며, 값이 변경될 때마다 컴포넌트의 렌더링 결과물에 영향을 준다.

앱 내에서는 서버,지역,전역으로 분류를 할 수 있으며. 내부 API만으로도 관리를 할 수 있다.

하지만 상태의 복잡성으로 인해서 Redux,MobX,Recoil,zustand,jotai 같은 외부 상태 라이브러리를 주로 활용한다.

### 지역 상태
컴포넌트 내부에서 사용되는 상태 ex) 체크박스의 체크 여부, 폼의 입력값

### 전역 상태
앱 전체에 공유하는 상태를 의미, 여러 개의 컴포넌트가 전역상태를 사용할 수 있다.

상태가 변경되면 컴포넌트들도 업데이트가 됨.

props drilling 문제를 피할수 있음.

### 서버 상태

외부 서버에 저장해야하는 상태들을 의미함.

서버 상태는 지역 상태 혹은 전역 상태와 동일한 방법으로 관리되며, 최근에는 react-query,swr과 같은 외부 라이브러리를 사용하여 관리함.


## 상태관리 가이드

상태는 복잡성을 증가시키고 동작을 예측하기 어렵게 만든다. 

업데이트마다 리렌더링이 발생하기 때문에 유지보수 및 성능 관점에서 상태의 개수를 최소화하는게 바람직하다.

가능하다면, 상태가 없는 Stateless 컴포넌트를 활용하는 게 좋다.

## 값을 상태로 정의할 시 고려해야하는 사항

### 시간이 지나도 변하지 않는다면 상태가 아니다.

상태는 렌더링에 영향을 주고,

변하지 않는 값은 컴퍼넌트에 들어갈시에는 리렌더링이 되면 새롭게 자꾸 그려내고 같은걸로 인식을 못한다.

객체참조의 동일성을 유지시키기 위해서 책은 useState 초기값에 넣거나, useRef로 객체값을 지정하여 쓸수가 있다. 하지만

useState는 기술적으론 동작이 되지만, 목적에 맞지 않게 쓰이는것이다. 

useState는 상태를 변화시키고 렌더링에 영향을 주는 훅이기에 적합하지 않다.


| 구분 | 코드 | 참조값 유지? | 리렌더링 유발? | 
|------|------|-------------|----------------|
| 변수 (const) | `const a = new Store()` | ❌ (계속 바뀜) | ❌ | 
| State | `useState(() => new Store())` | ✅ (유지됨) | ✅ (set 호출 시) | 
| Ref | `useRef(new Store())` | ✅ (유지됨) | ❌ (영향 없음) |

### 파생된 값은 상태가 아니다.

props,기존 상태에서 계산될 수 있는 값은 상태가 아니다.

리액트 앱에서 상태를 정의시 SSOT를 고려해야한다.

> `SSOT(Single Source Of Truth)`는 어떠한 데이터도 단 하나의 출처에서 생성하고 수정해야한다는 원칙을 의미하는 방법론이다.


```tsx
type UserEmailProps{
    initEmail : string;
}

const UserEmail:React.VFC<UserEmailProps> = ({initEmail}) => {
    const [email,setEmail]  = useState(initEmail);
    const onChnage = (e:React.ChangeEvent<HTMLInputElement>) => {
        setEmail(e.target.value);
    }
    return (
        <div>  
            <input type="text" value={email} onChange={onChnage}/>
        </div> 
        )

}

```

위 코드의 문제는 props의 값이 변경되어도 input태그의 value는 변경되지 않음.
useState초기값으로 설정한 값은 마운트 될떄 한번만 설정되고 나머지는 state는 독자적으로 관리함.

useEffect를 활용해서 하는 방법도 있찌만 이것은 좋은 방법이 아니다.

useEffect를 사용한 동기화 작업은 렌더링이후에 실행되어야 하는  리액트 외부 데이터와 동기화 할때만 사용해야하고,  내부에 존재하는 데이터를 상태와 동기화하는데 사용하면 안된다.

아래와 같이 더 나은대안이 있고,

```tsx
const UserEmail = ({ 
  email, 
  onEmailChange 
}: { 
  email: string; 
  onEmailChange: (e: React.ChangeEvent<HTMLInputElement>) => void; 
}) => {
  // useState 제거함! 
  
  return (
    <div>
      <input type="text" value={email} onChange={onEmailChange} />
    </div>
  );
};
```

공식문서에서는 컴포넌트를 순수하게 유지하기 목차란에

>"가능하면 렌더링만으로 로직을 표현하고, 이벤트 핸들러에 넣을 수 없는 부수 효과(side effect)가 필요할 때만 마지막 수단으로 useEffect를 사용하라"

이라고 나와있다.