# 비동기

## fetch

```tsx
fetch('https://api.sample.com').then((res) => res.json())
```

한계점:

1. 새로운 API요청 정책이 추가될때마다 계속 호출 코드를 수정해야하는 번거러움.
2. 컴퍼넌트 내부에 깊숙이 자리잡은 비동기 호출 코드는 이런 변경 요구에 취약함.

해결법:

1. 서비스 레이어로 분리하기
    - 다른 영역에서 처리되어야한다.
    - fetch함수로 많은 기능을 직접 구ㅎ녀해야함.
2. axios 활용하기
    
    ```tsx
    const apiRequester = axios.create({
      baseURL: "https://api.baemin.com",
      timeout: 5000,
    });
    ```
    
- 각서버에의 API 엔트리가 2개이상일 경우 2개이상의 api요청을 처리하는 인스턴스 따로 구성
    - 각각 대응이 가능하다는 장점이 있음.
- 인터셉터 사용하기
    - 빌더 패턴: 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가
    
    ```tsx
    const api = APIBuilder.get("/apis/web/jobs")
      .withCredentials(true)
      .params({ name, size })
      .build();
    ```
    
    - 단점: 보일러 플레이트코드가 많다.
    - 장점: 옵션이 다양한 경우, 인터셉터를 설정값에 따라 적용하고, 필요없는 인터셉터는 선택적으로 사용할 수 있다는 장점이 있다.
- 타입 안정성
    - 응답타입 지정
    
    ```tsx
    interface Response<T> {
      data: T;
      status: string;
      errorCode?: string;
    }
    
    const fetchCart = (): AxiosPromise<Response<FetchCartResponse>>
    ```
    
    같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 하나의 response타입으로 묶일 수 있다.
    
    - 통일할때 주의점
        - response타입을 api내서 처리하고 싶은 생각이 들수 있는데, 이럴 땐 응답이 없는 update,create같은 응답이 없을수 있는 api를 처리하기는 까다로워진다.
        
        ```tsx
        interface response {
        	data:{
        		cartItems:CartItems[];
        		forPass: unknown;
        	};
        };
        ```
        
        ex) api요청 및 응답값중 하나의 api서버에서 다른 api서버로 넘겨주기만 하는 값도 존재할 수 있음
        
        - forPass안에 프론트 로직에서 사용해야하는 값이 있다하면, 여전히 어떤 값이 들어오는지 모르는 상태라 unknown을 유지함.
        
        but, 이미 설계된 프로덕트에서 쓰고 있는 값이라면 프론트 로직에 써야하는 값에 대해서만 타입을 선언한 다음 사용하자.
        
        ```tsx
        type ForPass ={
        	type:'A'|'B'|'C';
        };
        
        const isTargetValue = () => (data.forPass as ForPass).type === 'A')
        ```
        
    - View Model
        - api 변경에 따른 범위를 한정해줘야함
        - view 모델을 이용하면 api응답이 바뀌어도 ui가 깨지지 않게 개발 가능.
    
    ```tsx
    interface ApiResponse {
      items: Product[]
    }
    
    // 2. 뷰모델 (UI에서 사용할 형태로 변환)
    class ProductListViewModel {
      readonly totalCount: number;
      readonly products: Product[];
      
      constructor(apiResponse: ApiResponse) {
        this.totalCount = apiResponse.items.length;
        this.products = apiResponse.items;
      }
    }
    
    const fetchProducts = async () => {
      const response = await api.get<ApiResponse>('/api/products');
      return new ProductListViewModel(response.data);  // 뷰모델로 변환
    };
    
    // 4. 컴포넌트는 뷰모델만 사용
    const ProductList = () => {
      const viewModel = useFetchProducts();
      
      return (
        <div>
          <h2>총 {viewModel.totalCount}개</h2>
          {viewModel.products.map(item => (
            <Product key={item.id} {...item} />
          ))}
        </div>
      );
    };
    ```
    

장점: 따로 UI를 깨지지 않게 개발 가능. UI에서 로직을 추가하여 처리할 필요 없이 간편하게 새로운 필드를 뷰 모델에 추가 할 수 있음.

문제점: 

1. 하나의 도메인에 여러가지의 타입과 클래스가 필요함. 그래서 관리가 쉽지않다. (관리 비용이 비쌈)
2.  viewModel에서 임의로 추가한 내용을 백엔드에서 모를수도 있고, 백엔드와의 소통이 재대로 없을시에 의사소통의 오류가 되서 혼란을 야기함.
3. 그래서 추상화가 장점이자 단점이 될수 있음.

- 런타임에서 응답 타입 검증하기
    - superstruct 라이브러리
        - 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있다.
        - 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안
    
    ```tsx
    import {assert,is,validate,object,number,string,array} from 'supserstruct'
    
    // superstruct의 object() 모율의 반환 결과.
    const Article = object({
    	id:number();
    	titile:string();
    	tags:array(string();
    	author:object({
    		id:number()
    		})
    	})
    	
    	const data = {
    		id:32,
    		title:'hello world',
    		tags:['news','feature'],
    		author:{
    			id:1
    		}
    	}
    	
    	assert(data,Article)
    	is(data,Article);
    	validate(data,Article)
    ```
    
    공식 문서의 코드.
    
    assert,is,validate는 데이터의 모든 유효성검사를 도와주는 모듈이고, 스키마와 부합하는지 검사를 하는것.
    
    Article이라는 변수의 superstrict의 object() 모듈의 반환하고, 이걸 유효성에 맞게 부합하는지 검사하는 내용.
    
    ```tsx
    import { object, number, string, assert, is, validate } from "superstruct";
    
    // 1. 스키마 정의
    const User = object({
      id: number(),
      email: string(),
      name: string(),
    });
    
    // 2. 타입 추론
    type User = Infer<typeof User>;
    
    // 3. 검증 함수들
    const data = { id: 1, email: "test@email.com", name: "홍길동" };
    
    // assert - 실패 시 에러 던짐
    assert(data, User);
    
    // is - true/false 반환
    if (is(data, User)) {
      console.log("유효함");
    }
    
    // validate - [error, data] 튜플 반환
    const [error, validData] = validate(data, User);
    if (error) {
      console.log("검증 실패");
    }
    ```
    

컴파일 단계가 아닌 런타임에서도 적절한 데이터인지를 확인하는 검사가 필요할 때, 유용하게 쓰일 수 있다.

실제 활용

```tsx
// API 응답 타입
interface ListItem {
  id: string;
  content: string;
}

// Superstruct 스키마
const ListItemSchema = object({
  id: string(),
  content: string(),
});

// 검증 함수
function validateListItems(items: ListItem[]) {
  items.forEach(item => assert(item, ListItemSchema));
}

// API 호출 시 사용
const fetchList = async (): Promise<ListResponse> => {
  const { data } = await api.get('/apis/get-list');
  
  // 런타임 검증 추가!
  validateListItems(data.items);
  
  return { data };
};
```

fetchList함수에 superstruct로 작성한 검증 함수를 추가하면 런타임 유효성 검사를 진행할 수 있게됨.


