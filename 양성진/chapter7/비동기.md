# 비동기

## fetch

```tsx
fetch('https://api.sample.com').then((res) => res.json())
```

한계점:

1. 새로운 API요청 정책이 추가될때마다 계속 호출 코드를 수정해야하는 번거러움.
2. 컴퍼넌트 내부에 깊숙이 자리잡은 비동기 호출 코드는 이런 변경 요구에 취약함.

해결법:

1. 서비스 레이어로 분리하기
    - 다른 영역에서 처리되어야한다.
    - fetch함수로 많은 기능을 직접 구ㅎ녀해야함.
2. axios 활용하기
    
    ```tsx
    const apiRequester = axios.create({
      baseURL: "https://api.baemin.com",
      timeout: 5000,
    });
    ```
    
- 각서버에의 API 엔트리가 2개이상일 경우 2개이상의 api요청을 처리하는 인스턴스 따로 구성
    - 각각 대응이 가능하다는 장점이 있음.
- 인터셉터 사용하기
    - 빌더 패턴: 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가
    
    ```tsx
    const api = APIBuilder.get("/apis/web/jobs")
      .withCredentials(true)
      .params({ name, size })
      .build();
    ```
    
    - 단점: 보일러 플레이트코드가 많다.
    - 장점: 옵션이 다양한 경우, 인터셉터를 설정값에 따라 적용하고, 필요없는 인터셉터는 선택적으로 사용할 수 있다는 장점이 있다.
- 타입 안정성
    - 응답타입 지정
    
    ```tsx
    interface Response<T> {
      data: T;
      status: string;
      errorCode?: string;
    }
    
    const fetchCart = (): AxiosPromise<Response<FetchCartResponse>>
    ```
    
    같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 하나의 response타입으로 묶일 수 있다.
    
    - 통일할때 주의점
        - response타입을 api내서 처리하고 싶은 생각이 들수 있는데, 이럴 땐 응답이 없는 update,create같은 응답이 없을수 있는 api를 처리하기는 까다로워진다.
        
        ```tsx
        interface response {
        	data:{
        		cartItems:CartItems[];
        		forPass: unknown;
        	};
        };
        ```
        
        ex) api요청 및 응답값중 하나의 api서버에서 다른 api서버로 넘겨주기만 하는 값도 존재할 수 있음
        
        - forPass안에 프론트 로직에서 사용해야하는 값이 있다하면, 여전히 어떤 값이 들어오는지 모르는 상태라 unknown을 유지함.
        
        but, 이미 설계된 프로덕트에서 쓰고 있는 값이라면 프론트 로직에 써야하는 값에 대해서만 타입을 선언한 다음 사용하자.
        
        ```tsx
        type ForPass ={
        	type:'A'|'B'|'C';
        };
        
        const isTargetValue = () => (data.forPass as ForPass).type === 'A')
        ```
        
    - View Model
        - api 변경에 따른 범위를 한정해줘야함
        - view 모델을 이용하면 api응답이 바뀌어도 ui가 깨지지 않게 개발 가능.
    
    ```tsx
    interface ApiResponse {
      items: Product[]
    }
    
    // 2. 뷰모델 (UI에서 사용할 형태로 변환)
    class ProductListViewModel {
      readonly totalCount: number;
      readonly products: Product[];
      
      constructor(apiResponse: ApiResponse) {
        this.totalCount = apiResponse.items.length;
        this.products = apiResponse.items;
      }
    }
    
    const fetchProducts = async () => {
      const response = await api.get<ApiResponse>('/api/products');
      return new ProductListViewModel(response.data);  // 뷰모델로 변환
    };
    
    // 4. 컴포넌트는 뷰모델만 사용
    const ProductList = () => {
      const viewModel = useFetchProducts();
      
      return (
        <div>
          <h2>총 {viewModel.totalCount}개</h2>
          {viewModel.products.map(item => (
            <Product key={item.id} {...item} />
          ))}
        </div>
      );
    };
    ```
    

장점: 따로 UI를 깨지지 않게 개발 가능. UI에서 로직을 추가하여 처리할 필요 없이 간편하게 새로운 필드를 뷰 모델에 추가 할 수 있음.

문제점: 

1. 하나의 도메인에 여러가지의 타입과 클래스가 필요함. 그래서 관리가 쉽지않다. (관리 비용이 비쌈)
2.  viewModel에서 임의로 추가한 내용을 백엔드에서 모를수도 있고, 백엔드와의 소통이 재대로 없을시에 의사소통의 오류가 되서 혼란을 야기함.
3. 그래서 추상화가 장점이자 단점이 될수 있음.

- 런타임에서 응답 타입 검증하기
    - superstruct 라이브러리
        - 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있다.
        - 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안
    
    ```tsx
    import {assert,is,validate,object,number,string,array} from 'supserstruct'
    
    // superstruct의 object() 모율의 반환 결과.
    const Article = object({
    	id:number();
    	titile:string();
    	tags:array(string();
    	author:object({
    		id:number()
    		})
    	})
    	
    	const data = {
    		id:32,
    		title:'hello world',
    		tags:['news','feature'],
    		author:{
    			id:1
    		}
    	}
    	
    	assert(data,Article)
    	is(data,Article);
    	validate(data,Article)
    ```
    
    공식 문서의 코드.
    
    assert,is,validate는 데이터의 모든 유효성검사를 도와주는 모듈이고, 스키마와 부합하는지 검사를 하는것.
    
    Article이라는 변수의 superstrict의 object() 모듈의 반환하고, 이걸 유효성에 맞게 부합하는지 검사하는 내용.
    
    ```tsx
    import { object, number, string, assert, is, validate } from "superstruct";
    
    // 1. 스키마 정의
    const User = object({
      id: number(),
      email: string(),
      name: string(),
    });
    
    // 2. 타입 추론
    type User = Infer<typeof User>;
    
    // 3. 검증 함수들
    const data = { id: 1, email: "test@email.com", name: "홍길동" };
    
    // assert - 실패 시 에러 던짐
    assert(data, User);
    
    // is - true/false 반환
    if (is(data, User)) {
      console.log("유효함");
    }
    
    // validate - [error, data] 튜플 반환
    const [error, validData] = validate(data, User);
    if (error) {
      console.log("검증 실패");
    }
    ```
    

컴파일 단계가 아닌 런타임에서도 적절한 데이터인지를 확인하는 검사가 필요할 때, 유용하게 쓰일 수 있다.

실제 활용

```tsx
// API 응답 타입
interface ListItem {
  id: string;
  content: string;
}

// Superstruct 스키마
const ListItemSchema = object({
  id: string(),
  content: string(),
});

// 검증 함수
function validateListItems(items: ListItem[]) {
  items.forEach(item => assert(item, ListItemSchema));
}

// API 호출 시 사용
const fetchList = async (): Promise<ListResponse> => {
  const { data } = await api.get('/apis/get-list');
  
  // 런타임 검증 추가!
  validateListItems(data.items);
  
  return { data };
};
```

fetchList함수에 superstruct로 작성한 검증 함수를 추가하면 런타임 유효성 검사를 진행할 수 있게됨.


## API 상태 관리하기

### 상태관리 라이브러리 호출

- redux/mobX방식
    - 비교적 초기에 나온 상태 관리 라이브러리
        
        ```tsx
        // Redux 예시
        const getHistoryList = async (newState) => {
          // 1. 상태 변경 dispatch
          dispatch(changeSearchState(newSearchState));
          
          // 2. API 호출
          const response = await getHistories(newSearchState);
          
          // 3. 결과 저장 dispatch
          dispatch(fetchData(response));
        };
        
        // 인터셉터에서도 매번 dispatch
        API.interceptors.request.use((config) => {
          store.dispatch(setApiCall({ status: 'Request' }));  // 로딩 시작
          return config;
        });
        
        API.interceptors.response.use((response) => {
          store.dispatch(setApiCall({ status: 'None' }));  // 로딩 끝
          return response;
        });
        ```
        
    - Redux
        - redux는 비동기 상태가 아닌 전역 상태를 위해 만들어진 라이브러리
        - middleware라고 불리는 여러 도구를 도입해 비동기 상태를 관리함.
    - Mobx
        - 비동기 상태관리가 어려운걸 개선하기 위해 비동기 콜백 함수를 분리하여 액션으로 만듬.
        - runInAction과 같은 메서드를 사용하여 상태 변경을 처리함.
        - **불필요한 재렌더링**: 다른 컴포넌트가 구독 중이면 함께 리렌더를 함.
    
    ### hook으로 호출
    
    - React-query나 useSwr같은 후글 사용하는게 더 간단함.
    
    ```tsx
    // 1. Job 목록 조회 훅
    const useFetchJobList = () => {
      return useQuery(["fetchJobList"], async () => {
        const response = await JobService.fetchJobList();
        return new JobList(response);  // 뷰모델 반환
      });
    };
    
    // 2. Job 업데이트 훅
    const useUpdateJob = (id: number, options) => {
      const queryClient = useQueryClient();
      
      return useMutation(
        ["updateJob", id],
        async (form) => {
          await JobService.updateJob(id, form);
        },
        {
          onSuccess: () => {
            // Job 업데이트 성공 시 목록 무효화 → 자동 재조회
            queryClient.invalidateQueries(["fetchJobList"]);
          },
          ...options,
        }
      );
    };
    
    // 3. 컴포넌트에서 사용
    const JobList = () => {
      const { data, isLoading, isError, error, refetch } = useFetchJobList();
      
      // 30초마다 폴링
      useInterval(() => refetch(), 30000);
      
      if (isLoading) return <LoadingSpinner />;
      if (isError) return <ErrorAlert error={error} />;
      
      return <>{data.map(job => <Job job={job} />)}</>;
    };
    ```
    

장점 :

- **간결함**: 훅만 호출하면 끝, 보일러플레이트 없음
- **캐시 자동 관리**: 같은 데이터 중복 요청 방지
- **로딩/에러 자동 관리**: `isLoading`, `isError` 자동 제공
- **의도치 않은 상태 변경 방지**: 각 컴포넌트가 독립적으로 관리
- **무효화 자동 처리**: 데이터 변경 시 자동으로 재조회

요즘은 저런 전역상태 관리 라이브러리를 react-query로 변경하고자 하는 시도가 많음.

변경하는 코드가 점점 추가되면 전역 상태 관리 스토어가 너무 비대해짐.

에러 발생,로딩중 같은 상태는 전역으로 관리할 필요도 없고, 다른컴퍼넌트가 에러인지 성공인지 구독하는 경우 컴포넌ㅌ의 결합도와 복잡도가 높아져 유지보수를 어렵게 만들 수 있음.
## API 에러 헨들링

### 타입가드 활용

- axios
    - isAxiosError 제공
- ErrorResponse를 사용하여 처리해야 할 axios에러 명시적으로 작성
    
    ```tsx
    interface ErrorResponse {
    	status:string;
    	serverDateTime:string;
    	errorCode:string;
    	errorMessage:string;
    }
    
    function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
      return axios.isAxiosError(error);
    }
    
    const onClickDeleteHistoryButton = async (id: string) => {
      try {
        await axios.post("https://...", { id });
        alert("주문 내역이 삭제되었습니다.");
      } catch (error: unknown) {
        if (isServerError(e) && e.response && e.response.data.errorMessage) {
          // 서버 에러일 때의 처리임을 명시적으로 알 수 있다
          setErrorMessage(e.response.data.errorMessage);
          return;
        }
        setErrorMessage("일시적인 에러가 발생했습니다. 잠시 후 다시 시도해주세요");
      }
    };
    ```
    

### 에러 서브클래싱

다양한 에러들을 명시적으로 표시하기 위해서 활용

### 서브 클래싱?

기존 클래스를 확장하여 새로운 클래스를 만드는 과정.

새로운 클래스는 상위 클래스의 모든 속성,메서드를 상속받아 사용 가능, 추가적인 메서드 상속을 정의 가능.

```tsx
const getOrderHistory = async (page:number):Promise<History> => {
	try{
		const { data } = await axios.get(`https://some.site?page=${page}`)
		const history = await JSON.parse(data);
	}
	catch(error){
		alert(error)
	}
}
```

주문 내역 불러오는 코드입니다.

’로그인 정보가 만료되었습니다.’,’유효하지 않는 요청 데이터입니다.’ 같은 에러 메시지가 표시
사용자가 어떤 에러가 발생하는지는 알지만 개발자 입장에서는 로그인 정보가 만료되었는지, 타임아웃이 발생한건지 데이터가 잘못 전달 됐는지 구분이 어려움

이때 서브클래싱을 활용하면 어떤 에러인지 구분이 가능해짐

```tsx
class OrderHttpError extends Error {
  private readonly privateResponse: AxiosResponse<ErrorResponse> | undefined;
  
  constructor(message?: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    this.name = "OrderHttpError";
    this.privateResponse = response;
  }
  
  get response(): AxiosResponse<ErrorResponse> | undefined {
    return this.privateResponse;
  }
}

class NetworkError extends Error {
  constructor(message = "") {
    super(message);
    this.name = "NetworkError";
  }
}

class UnauthorizedError extends Error {
  constructor(message: string, response?: AxiosResponse<ErrorResponse>) {
    super(message, response);
    this.name = "UnauthorizedError";
  }
}
```

인터셉터에 적합한 에러객체 전달

```tsx
const httpErrorHandler = (
  error: AxiosError<ErrorResponse> | Error
): Promise<Error> => {
  let promiseError: Promise<Error>;
  
  if (axios.isAxiosError(error)) {
    if (Object.is(error.code, "ECONNABORTED")) {
      promiseError = Promise.reject(new TimeoutError());
    } else if (Object.is(error.message, "Network Error")) {
      promiseError = Promise.reject(new NetworkError(""));
    } else {
      const { response } = error as AxiosError<ErrorResponse>;
      switch (response?.status) {
        case HttpStatusCode.UNAUTHORIZED:
          promiseError = Promise.reject(
            new UnauthorizedError(response?.data.message, response)
          );
          break;
        default:
          promiseError = Promise.reject(
            new OrderHttpError(response?.data.message, response)
          );
      }
    }
  } else {
    promiseError = Promise.reject(error);
  }
  
  return promiseError;
};
```

```tsx
const onActionError = (
  error: unknown,
  params?: Omit<AlertPopup, "type" | "message">
) => {
  if (error instanceof UnauthorizedError) {
    onUnauthorizedError(
      error.message,
      errorCallback?.onUnauthorizedErrorCallback
    );
  } else if (error instanceof NetworkError) {
    alert("네트워크 연결이 원활하지 않습니다. 잠시 후 다시 시도해주세요.", {
      onClose: errorCallback?.onNetworkErrorCallback,
    });
  } else if (error instanceof OrderHttpError) {
    alert(error.message, params);
  } else if (error instanceof Error) {
    alert(error.message, params);
  } else {
    alert(defaultHttpErrorMessage, params);
  }
};

const getOrderHistory = async (page: number): Promise<History> => {
  try {
    const { data } = await fetchOrderHistory({ page });
    const history = await JSON.parse(data);
    return history;
  } catch (error) {
    onActionError(error);
  }
};
```

### 인터셉터를 활용한 에러처리

인터셉터를 이용할시, http에러에 일관된 로직 적용할 수 있다.

```tsx
const httpErrorHandler = (
  error: AxiosError<ErrorResponse> | Error
): Promise<Error> => {
  (error) => {
    // 401 에러인 경우 로그인 페이지로 이동
    if (error.response && error.response.status === 401) {
      window.location.href = `${backOfficeAuthHost}/login?targetUrl=${window.location.href}`;
    }
    return Promise.reject(error);
  };
};

orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response,
  httpErrorHandler
);
```

### 에러 바운더리 활용한 에러 처리

- 에러 바운더리:
    - 리액트 컴포넌트 트리에서 에러가 발생할때 ,공통으로 에러를 처리하는 리액트 컴퍼넌트.
    - 사용하면, 컴퍼넌트 트리 하위에 있는 컴퍼넌트에서 에러 캐치.
    - 해당 에러에 가까운 부모 에러 바운더리에서 처리

리액트 컴포넌트 트리에서 발생한 에러를 공통으로 처리:

```tsx
import React, { ErrorInfo } from "react";
import ErrorPage from "pages/ErrorPage";

interface ErrorBoundaryProps {}
interface ErrorBoundaryState {
  hasError: boolean;
}

class ErrorBoundary extends React.Component
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(): ErrorBoundaryState {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    this.setState({ hasError: true });
    console.error(error, errorInfo);
  }
  
  render(): React.ReactNode {
    const { children } = this.props;
    const { hasError } = this.state;
    
    return hasError ? <ErrorPage /> : children;
  }
}

const App = () => {
  return (
    <ErrorBoundary>
      <OrderHistoryPage />
    </ErrorBoundary>
  );
};
```

### 상태관리 라이브러리

- redux
    
    ```tsx
    const apiCallSlice = createSlice({
      name: "apiCall",
      initialState,
      reducers: {
        setApiCall: (state, { payload: { status, urlInfo }}) => {
          /* API State를 채우는 logic */
        },
        setApiCallError: (state, { payload }: PayloadAction<any>) => {
          state.error = payload;
        },
      },
    });
    
    const setAxiosInterceptor = (store: EnhancedStore) => {
      API.interceptors.response.use(
        (response: AxiosResponse) => {
          const { method, url } = response.config;
          store.dispatch(
            setApiCall({
              status: ApiCallStatus.None,
              urlInfo: { url, method },
            })
          );
          return response?.data?.data || response?.data;
        },
        (error: AxiosError) => {
          if (error.response?.status === 401) {
            window.location.href = error.response.headers.location;
            return;
          } else if (error.response?.status === 403) {
            window.location.href = error.response.headers.location;
            return;
          } else {
            message.error(`[서버 요청 에러]: ${error?.response?.data?.message}`);
          }
          
          const {
            config: { url, method },
          } = error;
          store.dispatch(
            setApiCall({
              status: ApiCallStatus.None,
              urlInfo: { url, method },
            })
          );
          return Promise.reject(error);
        }
      );
    };
    ```
    
- MobX
    
    ```tsx
    class JobStore {
      jobs: Job[] = [];
      state: LoadingState = "PENDING";
      errorMsg = "";
      
      constructor() {
        makeAutoObservable(this);
      }
      
      async fetchJobList() {
        this.jobs = [];
        this.state = "PENDING";
        this.errorMsg = "";
        
        try {
          const projects = await fetchJobList();
          runInAction(() => {
            this.projects = projects;
            this.state = "DONE";
          });
        } catch (e) {
          runInAction(() => {
            this.state = "ERROR";
            this.errorMsg = e.message;
            showAlert();
          });
        }
      }
      
      get isLoading(): boolean {
        return state === "PENDING";
      }
    }
    
    const JobList = (): JSX.Element => {
      const [jobStore] = useState(() => new JobStore());
      
      if (job.isLoading) {
        return <Loader />;
      }
      
      return <>{jobStore.jobs.map((job) => <Item job={job} />)}</>;
    };
    ```
    

### react-query를 활용한 에러 처리

```tsx
const JobComponent: React.FC = () => {
  const { isError, error, isLoading, data } = useFetchJobList();
  
  if (isError) {
    return <div>{`${error.message}가 발생했습니다. 나중에 다시 시도해주세요.`}</div>;
  }
  
  if (isLoading) {
    return <div>로딩 중입니다.</div>;
  }
  
  return <>{data.map((job) => <JobItem key={job.id} job={job} />)}</>;
};
```

swr,react-query와 같은 데이터 패칭 라이브러리를 사용하면 요청에 대한 상태를 반환해주기 때문에 요청 상태를 확인하기 쉽다.

그 외에도

onError 콜백

```tsx
const useTodos = () =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    // ⚠️ looks good, but is maybe _not_ what you want
    onError: (error) =>
      toast.error(`Something went wrong: ${error.message}`),
  })
```

retry

```tsx
import { useQuery } from '@tanstack/react-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})
```

useSuspenseQuery 와 ErrorBoundary

```tsx
import { useSuspenseQuery } from '@tanstack/react-query'

function Component() {
  const { data } = useSuspenseQuery({ 
    queryKey: ['todos'],
    queryFn: fetchTodos,
    throwOnError: true 
  })
  
  // data는 항상 정의되어 있음 (로딩/에러는 Suspense/ErrorBoundary가 처리)
  return <div>{data.map(...)}</div>
}

// 사용 예시
<ErrorBoundary fallback={<div>Error occurred!</div>}>
  <Suspense fallback={<div>Loading...</div>}>
    <Component />
  </Suspense>
</ErrorBoundary>
```

- **Tanstack Query**의 isLoading, isError 등의 상태를 관리하지 않고, **Suspense**와 **ErrorBoundary**를 통해 자동화된 처리를 할 수 있다는 장점이 있음

등등 되게 많습니다.

### 그 외 에러처리 (커스텀 에러처리)

비즈니스 로직 유효성 검증으로 인한 커스텀 에러 처리:

```tsx
// 응답 예시
// httpStatus: 200
// {
//   "status": "C20005",
//   "message": "장바구니에 품절된 메뉴가 있습니다."
// }

const successHandler = (response: CreateOrderResponse) => {
  if (response.status === "SUCCESS") {
    return;
  }
  throw new CustomError(response.status, response.message);
};

const createOrder = (data: CreateOrderData) => {
  try {
    const response = apiRequester.post("https://...", data);
    successHandler(response);
  } catch (error) {
    errorHandler(error);
  }
};
```

인터셉터를 활용한 처리

```tsx
export const apiRequester: AxiosInstance = axios.create({
  baseURL: orderApiBaseUrl,
  ...defaultConfig,
});

export const httpSuccessHandler = (response: AxiosResponse) => {
  if (response.data.status !== "SUCCESS") {
    throw new CustomError(response?.data.message, response);
  }
  return response;
};

apiRequester.interceptors.response.use(httpSuccessHandler, httpErrorHandler);

const createOrder = (data: CreateOrderData) => {
  try {
    const response = apiRequester.post("https://...", data);
    successHandler(response);
  } catch (error) {
    // status가 SUCCESS가 아닌 경우 에러로 전달된다
    errorHandler(error);
  }
};
```

## API 모킹

서버 API가 완성되기 전에 개발을 진행해야 하는 상황에서 모킹(Mocking)을 활용하여 가짜 모듈로 개발할 수 있습니다.

**모킹의 장점:**

- 서버 개발 완료를 기다리지 않고 프론트엔드 개발 가능
- dev 서버 불안정 시에도 개발 가능
- 다양한 예외 케이스 테스트 용이
- Charles 등의 도구로 이슈 재현 가능

### JSON 파일 불러오기

간단한 조회용으로 사용

```tsx
const SERVICES:Service[]= [
  {
    id: 0,
    name: "배달의민족",
  },
  {
    id: 1,
    name: "만화경",
  },
];

export default SERVICES;
```

장점: 구현하기 매우 쉬움. 별도 설정 불필요

**단점:** 추후 실제 API URL로 변경 필요

### NextApiHandler 활용하기

하나의 파일 안에 하나의 핸들러를 default export로 구현해야 하며 파일의 경로가 요청경로가 됨.

```tsx
// api/mock/brand (파일경로가 api 요청경로가 됨)
import { NextApiHandler } from "next";

const BRANDS: Brand[] = [
  {
    id: 1,
    label: "배민스토어",
  },
  {
    id: 2,
    label: "비마트",
  },
];

const handler: NextApiHandler = (req, res) => {
  // request 유효성 검증
  res.json(BRANDS);
};

export default handler;
```

응답하고자 하는값을 정의하고, 핸들러 안에서 요청에대한 값을 정의하면 된다.

### API요청 핸들러에 분기 추가하기

```tsx
const mockFetchBrands = (): Promise<FetchBrandsResponse> => new Promise((resolve) => {
  setTimeout(() => {
    resolve({
      status: "SUCCESS",
      message: null,
      data: [
        {
          id: 1,
          label: "배민스토어",
        },
        {
          id: 2,
          label: "비마트",
        },
      ],
    });
  }, 500);
});

const fetchBrands = () => {
  if (useMock) {
    return mockFetchBrands();
  }
  return requester.get("/brands");
};
```

- api요청을 훅 또는 별도의 함수로 만들고, 조건에 따라 목업함수를 내보내거나 실제 함수를 내보낼수 있다.
    - 장점: 유지보수할때 편하다. 개발 완료 후, 유지보수시 사용 가능.
    - 단점: 실제 함수일때 아닐때, 분기처리를 해야해서 번거로움이 있음.

### axios-mock-adapter로 모킹하기

서비스함수에 분기처리를 원치 않는다면 라이브러리를 사용하자.

```tsx
// mock/index.ts
import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import fetchOrderListSuccessResponse from "fetchOrderListSuccessResponse.json";

interface MockResult {
  status?: number;
  delay?: number;
  use?: boolean;
}

const mock = new MockAdapter(axios, { onNoMatch: "passthrough" });

export const fetchOrderListMock = () =>
  mock
    .onGet(/\/order\/list/)
    .reply(200, fetchOrderListSuccessResponse);
```

axios요청을 가로채서 응답값을 반환함.

단순히 응답 바디만 모킹할수도 있지만, 상태코드,응답 지연 시간등을 추가로 설정할 수도 있다. 이에 따라 다양한 http상태 코드에 따라 목업을 정의할 수 있다.

다양한 HTTP 상태 코드와 지연 시간 설정 가능:

```tsx
export const lazyData = (
  status: number = Math.floor(Math.random() * 10) > 0 ? 200 : 200,
  successData: unknown = defaultSuccessData,
  failData: unknown = defaultFailData,
  time = Math.floor(Math.random() * 1000)
): Promise<any> =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve([status, status === 200 ? successData : failData]);
    }, time);
  });

export const fetchOrderListMock = ({
  status = 200,
  time = 100,
  use = true
}: MockResult) =>
  use &&
  mock
    .onGet(/\/order\/list/)
    .reply(() =>
      lazyData(status, fetchOrderListSuccessResponse, undefined, time)
    );
```

axios-mock-adapter를 사용하면 get뿐만이 아니라 post,put,delete등 다른 http메서드에 대한 목업을 작성할 수 있게 된다. 

networkError,timeoutError 등을 메서드로 제공하기 떄문에 다음처럼 임의로 에러를 발생시킬수 있다.

```tsx
export const fetchOrderListMock = () => mock.onPost(/\/order\/list/).networkError();
```

### 목업 사용 여부 제어하기

```tsx
const useMock = Object.is(REACT_APP_MOCK, "true");

const mockFn = ({ status = 200, time = 100, use = true }: MockResult) => use &&
  mock.onGet(/\/order\/list/).reply(() =>
    new Promise((resolve) =>
      setTimeout(() => {
        resolve([
          status,
          status === 200 ? fetchOrderListSuccessResponse : undefined,
        ]);
      }, time)
    )
  );

if (useMock) {
  mockFn({ status: 200, time: 100, use: true });
}
```

- axios-mock-adapter는 실제 API 요청을 보내지 않아 브라우저 개발자 도구의 네트워크 탭에서 확인 불가
- react-query-devtools, redux test tool 등 별도 도구 활용 필요
- 네트워크 요청 확인이 필요하면 Cypress 같은 도구의 웹훅 사용
- 최근에는 MSW(서비스워커 활용 라이브러리)를 도입하는 팀도 있음