# Git Rebase를 활용한 브랜치 동기화 대화
---

**주니어**: 선배님, 제가 `git push`를 하려고 하는데 "브랜치가 diverged 되었다"는 메시지가 나와요. 이게 무슨 뜻인가요?

**시니어**: 아, 로컬 브랜치와 원격 브랜치가 서로 다른 방향으로 진행되었다는 뜻이야. 쉽게 말하면, 네가 작업하는 동안 다른 팀원이 이미 원격 저장소에 커밋을 push해둔 상황이지.

**주니어**: 그럼 어떻게 해야 하나요?

**시니어**: 두 가지 방법이 있어. `git pull`을 하거나 `git pull --rebase`를 하는 거야. 각각 장단점이 있지.

**주니어**: 차이가 뭔가요?

**시니어**: 먼저 `git pull`은 merge 방식이야. 원격의 변경사항을 가져와서 너의 로컬 커밋과 합치는 거지. 이때 "merge commit"이라는 새로운 커밋이 하나 생성돼.

```
# git pull (merge 방식)
      A---B---C  (로컬)
     /         \
D---E---F---G---M  (M은 merge commit)
        |
    (원격의 새 커밋들)
```

**주니어**: 음... 그럼 `git pull --rebase`는요?

**시니어**: rebase는 "재배치"라는 뜻이야. 네 로컬 커밋을 임시로 치워두고, 원격의 최신 커밋들을 먼저 가져온 다음, 그 위에 네 커밋을 다시 올려놓는 거지.

```
# git pull --rebase
D---E---F---G---A'---B'---C'  (선형 히스토리)
        |
    (원격)  (네 커밋들이 재배치됨)
```

**주니어**: 아! 그래서 히스토리가 일직선이 되는 거네요?

**시니어**: 정확해! 방금 네 상황을 예로 들어볼게. 원격에 48개의 새로운 커밋이 있었고, 너는 로컬에 1개의 커밋이 있었어.

**주니어**: 네, 맞아요.

**시니어**: `git pull --rebase`를 실행하면 이런 과정이 일어나:

1. **준비 단계**: 네 로컬 커밋 1개를 임시 저장소에 보관
2. **업데이트 단계**: 원격의 48개 커밋을 로컬로 가져옴
3. **재배치 단계**: 48개 커밋 위에 네 1개 커밋을 다시 적용
4. **완료**: 총 49개의 커밋이 깔끔한 일직선으로 정렬됨

**주니어**: 그런데 충돌이 날 수도 있지 않나요?

**시니어**: 좋은 질문이야! 만약 네 커밋과 원격 커밋이 같은 파일의 같은 부분을 수정했다면 충돌이 발생할 수 있어. 그럴 때는:

```bash
# 충돌 발생 시
git status  # 어떤 파일에서 충돌이 났는지 확인
# 충돌 해결 후
git add .
git rebase --continue

# 또는 rebase를 취소하고 싶다면
git rebase --abort
```

**주니어**: 다행히 제 경우엔 충돌 없이 바로 성공했어요!

**시니어**: 그럼 이제 `git push`만 하면 끝이야. rebase 후에는 로컬이 원격보다 앞서 있는 상태가 되니까, 문제없이 push할 수 있어.

**주니어**: 그런데 선배님, 언제 merge를 쓰고 언제 rebase를 써야 하나요?

**시니어**: 좋은 질문이야. 일반적인 가이드라인은:

**Rebase를 사용할 때:**
- 개인 브랜치에서 작업할 때
- 커밋 히스토리를 깔끔하게 유지하고 싶을 때
- 아직 push하지 않은 로컬 커밋을 정리할 때

**Merge를 사용할 때:**
- 이미 공유된(push된) 브랜치를 다룰 때
- 팀의 컨벤션이 merge를 선호할 때
- 히스토리의 실제 흐름을 보존하고 싶을 때

**주니어**: 아, 그래서 아직 push하지 않은 제 1개 커밋에는 rebase가 안전했던 거네요!

**시니어**: 정확해! 중요한 원칙 하나만 기억해: **"이미 push한 커밋은 rebase하지 마라"**. 다른 사람들이 이미 그 커밋을 기반으로 작업하고 있을 수 있으니까.

**주니어**: 만약 실수로 push한 커밋을 rebase하면 어떻게 되나요?

**시니어**: 히스토리가 꼬여서 팀원들이 혼란을 겪게 돼. 각자의 로컬 저장소가 서로 다른 히스토리를 가리키게 되거든. 그럼 강제 push(`git push --force`)를 해야 하는데, 이건 정말 위험해.

**주니어**: 무섭네요...

**시니어**: 그래서 규칙을 잘 지키는 게 중요해. 정리하면:

```bash
# 안전한 워크플로우
git status                    # 현재 상태 확인
git pull --rebase             # 원격 변경사항 가져오기 (개인 브랜치)
# 충돌 해결 (필요시)
git push                      # 원격에 반영
```

**주니어**: 이제 이해했어요! 그런데 rebase에는 다른 기능도 있나요?

**시니어**: 있지! `git rebase -i` (interactive rebase)는 더 강력해. 여러 커밋을 하나로 합치거나(squash), 커밋 메시지를 수정하거나, 순서를 바꾸거나, 아예 삭제할 수도 있어.

```bash
git rebase -i HEAD~3  # 최근 3개 커밋을 대화형으로 수정
```

**주니어**: 와, 그건 나중에 꼭 배워보고 싶어요!

**시니어**: 하나씩 익혀가면 돼. 오늘은 `git pull --rebase`로 브랜치 동기화하는 것부터 확실히 익히고, 다음에 interactive rebase를 알려줄게.

**주니어**: 감사합니다, 선배님! 덕분에 rebase가 왜 유용한지 확실히 알게 됐어요.

**시니어**: 잘했어! 실전에서 여러 번 써보면서 익숙해지는 게 중요해. 실수해도 괜찮아, `git reflog`로 복구할 수 있으니까.

**주니어**: `git reflog`는 또 뭔가요?

**시니어**: 하하, 그건 다음 시간에! Git의 "타임머신"이라고만 해두자.

---

## 핵심 요약

### git pull --rebase가 해결한 문제
- 로컬 1개 커밋 + 원격 48개 커밋 = diverged 상태
- rebase로 49개 커밋을 선형으로 재정렬
- merge commit 없이 깔끔한 히스토리 유지
- 성공적으로 push 완료

### 기억해야 할 원칙
1. **개인 작업 브랜치**: rebase 사용
2. **공유된 브랜치**: merge 사용
3. **이미 push한 커밋은 rebase하지 않기**
4. **충돌 시**: 침착하게 해결 후 `git rebase --continue`
