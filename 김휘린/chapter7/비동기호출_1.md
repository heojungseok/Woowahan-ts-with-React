# 7장 비동기 호출 1

## API 요청

### fetch로 API 요청하기

책에서는 다음과 같은 코드를 예시로 비동기 fetch로 API 요청하는 예시를 먼저 보여준다.

```ts
import React, {useEffect, useState} from "react";

const CartBadge: React.FC = () => {
    const [cartCount, setCartCount] = useState(0);

    useEffect(()=>{
        fetch("https://api.baemin.com/cart")
         .then((response)=>response.json())
         .then(({cartItem})=>{
            setCartCount(cartItem.length)
         })
    },[])

    return <> {/* 컴포넌트 렌더링 */}
}
```

위 식은 제 기능은 소화하지만 여러 단점이 존재한다.  
백엔드 API가 변경되어야 하거나 '여러 서버에 API를 요청할 때 타임아웃 설정이 필요하다' 혹은 '모든 요청에 커스텀 헤더가 필요하다' 같은 새로운 API 요청 정책이 생기면 일일히 찾아서 수정해야하는 번거로움이 생긴다.

### 서비스 레이어로 분리하기

그렇다면 비동기 호출 코드는 UI 컴포넌트에서 분리되어 서비스레이어에서 처리되어야 한다.

위 코드를 기준으로 fetch 함수를 호출하는 부분이 서비스 레이어로 이동하고, 컴포넌트는 서비스 레이어의 비동기 함수를 호출하여 그 결과를 받아와 렌더링하는 흐름이 된다.

그러나 단순히 fetch 함수를 분리한다고 API 요청 정책이 추가되는 것을 해결하긴 어렵다.

다음은 타임아웃을 설정하기 위한 예시이다.

```ts
async function fetchCart() {
  const controller = new AbortController();

  const timeoutId = setTimeout(() => controller.abort(), 5000);

  const response = await fetch("https://api.baemin.com/cart", {
    signal: controller.signal,
  });

  clearTimeout(timeoutId);

  return response;
}
```

위 처럼 매번 구현하는 것도 번거로운 일이다.

### Axios 활용

fetch는 내장라이브러리이기 때문에 import나 설치 없이 사용 가능하지만 다양한 기능을 덧붙이려면 직접 구현해서 사용해야한다.

그래서 fetch 대신 Axios를 추천한다.

```ts
const apiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});

const fetchCart = (): AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse>("cart");

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<PostCartResponse> =>
  apiRequest.post<PostCartResponse>("cart", postCartRequest);
```

위처럼 한 API Entry가 담당하는 부분을 위처럼 인스턴스를 만들고, 각 요청을 만들 수 있다.

만약 API Entry가 2개 이상일 경우에는 각 서버의 기본 URL을 호출하도록 각 서버의 인스턴스를 따로 구성해야 한다.

### Axios 인터셉터 사용하기

각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수 있다.

이럴때 인터셉터 기능을 활용하여 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있다.

```ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

const getUserToken = () => "";
const getAgent = () => "";
const getOrderClientToken = () => "";
const orderApiBaseUrl = "";
const orderCartApiBaseUrl = "";
const defaultConfig = {};
const httpErrorHandler = () => {};

const apiRequester = AxiosInstance.create({
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});

const setRequestDefaultHeader = (requestConfig: AxiosRequestConfig) => {
  const config = requestConfig;
  config.headers = {
    ...config.headers,
    "Content-Type": "application/json; charset=utf-8",
    user: getUserToken(),
    agent: getAgent(),
  };
  return config;
};

const setOrderClientDefaultHeader = (requestConfig: AxiosRequestConfig) => {
  const config = requestConfig;
  config.headers = {
    ...config.headers,
    "Content-Type": "application/json; charset=utf-8",
    "order-client": getOrderClientToken(),
  };
  return config;
};

// interceptors 기능을 사용해 header를 설정하는 기능을 넣거나 에러를 처리할 수 있다.
apiRequester.interceptors.request.use(setRequestDefaultHeader);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: orderApiBaseUrl,
  ...defaultConfig,
});

// 기본 apiRequester와는 다른 헤더를 설정하는 인터셉터
orderApiRequester.interceptors.request.use(setOrderClientDefaultHeader);
orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response,
  httpErrorHandler
);

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: orderCartApiBaseUrl,
  ...defaultConfig,
});

orderCartApiRequester.interceptors.request.use(setOrderClientDefaultHeader);
```

위처럼 인터셉터들을 구성할 수 있다.

### 빌더 패턴

책의 내용과 약간 다르게 바라본 빌더 패턴

```ts
import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
} from "axios";

type ErrorHandler = (error: AxiosError) => Promise<never>;

class ApiBuilder {
  private baseURL = "";
  private timeout = 5000;
  private headers: Record<string, string> = {};
  private errorHandler?: ErrorHandler;
  private interceptorsConfigured = false;

  setBaseURL(url: string) {
    this.baseURL = url;
    return this;
  }

  setTimeout(ms: number) {
    this.timeout = ms;
    return this;
  }

  setHeader(key: string, value: string) {
    this.headers[key] = value;
    return this;
  }

  setHeaders(headers: Record<string, string>) {
    this.headers = { ...this.headers, ...headers };
    return this;
  }

  setErrorHandler(handler: ErrorHandler) {
    this.errorHandler = handler;
    return this;
  }

  private applyInterceptors(instance: AxiosInstance) {
    if (this.interceptorsConfigured) return;

    // 요청 인터셉터
    instance.interceptors.request.use((config: AxiosRequestConfig) => {
      config.headers = {
        ...config.headers,
        ...this.headers,
      };
      return config;
    });

    // 응답 인터셉터
    instance.interceptors.response.use(
      (response: AxiosResponse) => response,
      this.errorHandler ?? ((error) => Promise.reject(error))
    );

    this.interceptorsConfigured = true;
  }

  build(): AxiosInstance {
    const instance = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: this.headers,
    });

    this.applyInterceptors(instance);
    return instance;
  }
}

export default ApiBuilder;
```

대략 위와 같은 빌더 클래스가 있다고 하자.

그럼 아래와 같이 쉽게 여러 path들의 호출들을 생성해줄 수 있다.

```ts
import ApiBuilder from "./ApiBuilder";

const httpErrorHandler = async (error: any) => {
  console.error("HTTP ERROR:", error.message);
  throw error;
};

// 1️⃣ 일반 API 클라이언트
const api = new ApiBuilder()
  .setBaseURL("https://api.baemin.com")
  .setTimeout(5000)
  .setHeader("Content-Type", "application/json; charset=utf-8")
  .setHeader("user", "USER_TOKEN_ABC")
  .build();

// 2️⃣ 주문 전용 API 클라이언트
const orderApi = new ApiBuilder()
  .setBaseURL("https://api.baemin.com/order")
  .setHeaders({
    "Content-Type": "application/json; charset=utf-8",
    "order-client": "ORDER_CLIENT_TOKEN",
  })
  .setErrorHandler(httpErrorHandler)
  .build();

// 3️⃣ 장바구니 API 클라이언트
const cartApi = new ApiBuilder()
  .setBaseURL("https://api.baemin.com/cart")
  .setHeader("order-client", "ORDER_CLIENT_TOKEN")
  .build();
```

단점으로 매우 많은 보일러플레이트를 생성해야하지만, 구조가 탄탄하고 쉬운 유지보수를 원한다면 위와 같은 구조를 택할 수 있다.

### API 응답 타입 지정하기

여기서 설명하는 방법은 다음과 같다.

만약 기존 응답 타입이 다음과 같다.

#### 기존 응답 타입

```ts
// 예전 API 응답
{
  jobItems: [{ name: "Frontend Developer" }, { name: "Backend Developer" }];
}
```

#### 기존 뷰모델

```ts
interface JobListItemResponse {
  name: string;
}

interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems;
  }
}
```

#### 사용하는 UI 코드

```ts
// UI는 JobList 구조만 알고 있음
const jobList = new JobList(apiResponse);

console.log(jobList.totalItemCount); // ✅ 정상 작동
jobList.items.forEach((item) => console.log(item.name));
```

#### 문제 발생!! 백엔드에서 값 변경

```ts
// 새로운 API 응답
{
  jobs: [
    { title: "Frontend Developer" },
    { title: "Backend Developer" }
  ],
  count: 2
}
```

#### 걱정 No, 뷰모델만 손봐주면 끝

```ts
interface JobListResponseV2 {
  jobs: { title: string }[];
  count: number;
}

class JobList {
  readonly totalItemCount: number;
  readonly items: { name: string }[];

  constructor({ jobs, count }: JobListResponseV2) {
    this.totalItemCount = count;
    this.items = jobs.map((job) => ({ name: job.title }));
  }
}
```

### Superstruct를 사용해 런타임에서 응답 타입 검증하기!

#### Superstruct 란?

- Superstruct는 런타임 데이터 검증 라이브러리로, TypeScript의 타입이 사라지는 실행 시점에서도 데이터의 형태를 검사할 수 있게 해준다.
- 즉, API 응답이나 외부 입력이 예상한 구조인지 실제로 확인하는 역할을 한다.
- Zod와 비슷하지만 더 가볍고 함수형 스타일을 지향한다.

#### 왜 사용하나?

- TypeScript의 interface는 컴파일 시점에만 타입을 검사하기 때문에, 서버에서 잘못된 데이터가 오면 런타임 오류가 발생할 수 있다.
- Superstruct를 사용하면 이런 데이터를 실행 중에도 검증해 안전성을 높일 수 있다.
- 또한 한 번 정의한 스키마로 타입 추론까지 자동화되어 코드 중복을 줄인다.

#### GPT로 다시 만든 사용 예시

```ts
import { object, string, number, array, assert } from "superstruct";

// 스키마 정의
const User = object({
  id: number(),
  name: string(),
  hobbies: array(string()),
});

// 런타임 검증
const data = JSON.parse('{"id": 1, "name": "Hwirin", "hobbies": ["coding"]}');

// ✅ 올바르면 통과, ❌ 잘못된 구조면 즉시 에러
assert(data, User);

console.log("데이터 검증 통과!");
```

## API 상태 관리하기

이 장에서는 실제 API를 요청하는 코드는 컴포넌트 내에서 비동기 함수를 직접 호출하지 않는다고 설명한다.  
API의 성공,실패에 따른 상태가 관리되어야 하므로 상태관리 라이브러리의 액션이나 훅과 같이 재정의된 형태를 사용해야 한다고 설명한다.

### MobX

#### 장점

- makeAutoObservable을 통해 불변성 관리 없이도 자동으로 UI 갱신.
- 비즈니스 로직을 Store에 집중시킬 수 있음
- OOP 스타일의 구조로, 로직과 상태를 한곳에서 캡슐화 가능.
- Redux보다 보일러플레이트가 적음
- action/type/reducer 같은 반복 코드 없이 바로 상태 변경 가능.

#### 단점

- 캐싱, 리페칭, 동기화(stale) 등을 직접 구현해야 함. → API가 많아질수록 코드 복잡도 급증.
- Store에 불필요한 비동기 로직이 섞이기 쉬움
- API 호출, 에러 핸들링, UI 반응 로직이 모두 Store 안에 들어가 “비즈니스 로직 + 통신 로직 혼합” 구조가 되기 쉬움.
- 결과적으로 Store가 거대해지고 테스트가 어려워짐.
- 어디서 값이 바뀌었는지 추적하기 힘듦.

### React Query

#### 장점

- 서버 상태 관리에 특화
- 캐싱, 리페칭, 중복 요청 방지, 에러/로딩 자동 관리 등 서버 데이터의 생명주기를 자동으로 관리.
- 데이터 일관성 유지가 자동
- 캐시 키 기반으로 여러 컴포넌트에서 같은 데이터를 공유 가능.

#### 단점

- 비즈니스 로직과의 결합이 약함
- useQuery는 단순히 데이터 fetch + 캐시이므로,
  복잡한 계산/의존 관계는 별도 계층으로 분리해야 함.
- 캐시 정책이나 invalidate 조건을 세밀하게 제어하려면 학습이 필요.
