# 7장 비동기 호출 2

## API 에러 핸들링

### 타입 가드 활용하기

서버에서 에러가 발생하면 다음과 같은 에러 형태를 던져준다고 가정하자.

```ts
interface ErrorResponse {
  status: string;
  serverDateTime: string;
  errorCode: string;
  errorMessage: string;
}
```

만약 클라이언트에서 Axios를 사용해서 요청을 보냈다가 실패하면 Axios는 AxiosError객체를 던진다.  
이때 error.response?.data 에 서버에서 보낸 응답이 들어있다. (지금 위에 작성했던 ErrorResponse형태처럼 서버에서 정의한 에러응답 타입으로 말이다.)

타입 가드는 타입스크립트에서

- 진짜 AxiosError인지
- 그 AxiosError의 response.data가 ErrorResponse 타입인지

위 두 항목을 확인한 뒤 타입을 좁혀주는 것이 목적이다.

```ts
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```

여기서 is 문법은 위 함수의 리턴이 true이면 error가 `AxiosError<ErrorResponse>`이라고 믿게 해준다.  
실제로 return에 써있는 `axios.isAxiosError(error)`의 역할은 AxiosError인지 확인만 해주는 것이다.

따라서 위 타입가드함수를 사용하면 실제로 error.response.data가 ErrorResponse 형태가 아니어도 그렇다고 믿게 된다.

#### 그래서 더 정확하게 검사하려면?

```ts
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  if (!axios.isAxiosError(error)) {
    return false;
  }

  const data = error.response?.data;
  if (!data) return false;

  return (
    typeof data.status === "string" &&
    typeof data.serverDateTime === "string" &&
    typeof data.errorCode === "string" &&
    typeof data.errorMessage === "string"
  );
}
```

이렇게 하면 실제 타입까지 확인 가능!

### 에러 서브클래싱하기

API요청시 단순한 서버 에러도 발생하지만 인증에러, 네트워크에러, 타임아웃 등 다양한 에러가 발생하기도 한다.  
우리는 그때마다 다양한 처리를 하기위해 명시적으로 표시하길 원한다.  
왜냐? 사용자가 네트워크 오류이다, 타임아웃 오류이다. 이런 에러 메시지를 그저 보는것은 아무 의미가 없다.  
어떤 행동을 해야하는지, 아니면 에러가 발생하여 어떻게 된다. 하는 그런것이 필요하기 때문이다.

그래서 다음과 같은 서브클래싱 방법을 사용하면 편리하다.

#### 에러 서브클래스 정의

```ts
// 서버가 '정상적으로 응답했지만' 비즈니스 로직 실패일 때 사용하는 에러
class OrderHttpError extends Error {
  private readonly privateResponse: AxiosResponse<ErrorResponse> | undefined;

  constructor(message: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    // super(message): Error 내부의 message, stack 등 기본 필드를 초기화한다.

    this.name = "OrderHttpError";
    // name: 에러의 의미적 라벨로 운영 로그와 디버깅에서 매우 중요하다.

    this.privateResponse = response;
    // 서버에서 받은 원본 response를 담아둔다. (필요하면 UI에서 세부 정보 확인 가능)
  }

  get response() {
    // getter: UI나 다른 계층에서 error.response 로 접근 가능하도록 함
    return this.privateResponse;
  }
}

// 네트워크가 끊겼거나, 서버 자체에 도달하지 못했을 때 사용하는 에러
class NetworkError extends Error {
  constructor(message = "") {
    super(message);
    this.name = "NetworkError";
  }
}

// 인증이 필요하거나 토큰이 만료되었을 때 발생하는 에러
class UnauthorizedError extends Error {
  constructor(message: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    this.name = "UnauthorizedError";
  }
}
```

#### Axios에러를 의미 기반 에러로 변환하는 함수

이 함수는 기술적 오류(AxiosError)를 받아서
UI가 이해하기 쉬운 “의미 기반 에러 객체”로 변환하는 역할을 한다.

```ts
const httpErrorHandler = (error: AxiosError<ErrorResponse>): Promise<Error> => {
  let promiseError: Promise<Error>;

  // (1) 먼저, 이 에러가 AxiosError인지 검사한다.
  // UI는 AxiosError의 구조를 알 필요가 없다.
  if (axios.isAxiosError(error)) {
    // (2) timeout 발생 시 Axios는 code="ECONNABORTED" 를 넣어준다.
    if (Object.is(error.code, "ECONNABORTED")) {
      // 기술적 에러를 의미적 에러(TimeoutError)로 치환한다.
      promiseError = Promise.reject(new TimeoutError());

      // (3) 네트워크 자체가 끊긴 경우 → message가 "Network Error" 로 고정됨
    } else if (Object.is(error.message, "Network Error")) {
      promiseError = Promise.reject(new NetworkError());

      // (4) timeout도 아니고 network error도 아니면서 서버가 응답한 경우
    } else {
      const { response } = error as AxiosError<ErrorResponse>;

      // (5) 서버 status 에 따라 의미적으로 분리
      switch (response?.status) {
        case HttpStatusCode.UNAUTHORIZED:
          // 인증 문제 → UnauthorizedError 로 명확히 선언
          promiseError = Promise.reject(
            new UnauthorizedError(response.data.message, response)
          );
          break;

        default:
          // 그 외 대부분의 서버 오류 → 도메인 에러 OrderHttpError 로 변환
          promiseError = Promise.reject(
            new OrderHttpError(response?.data.message, response)
          );
      }
    }
  } else {
    // (6) AxiosError가 아니라 내부 JS 오류(TypeError 등)인 경우 그대로 던짐
    promiseError = Promise.reject(error);
  }

  // (7) 변환된 에러를 던져서 catch 또는 onError 로 전달
  return promiseError;
};
```

#### UI에서 에러를 의미 기반으로 처리하는 onActionError

UI단에서는 AxiosError의 내부 구조를 모른다.  
오직 "이 에러의 의미가 무엇인가?" 만 보고 처리한다.

```ts
const onActionError = ({
  error,
  params,
}: {
  error: unknown; // catch(error) 로 들어온 어떤 값이든 받을 수 있음
  params?: Omit<AlertPopup, "type" | "message">;
}) => {
  // (1) 인증 만료 / 로그인 필요
  if (error instanceof UnauthorizedError) {
    onUnauthorizedError(
      error.message,
      errorCallback?.onUnauthorizedErrorCallback
    );
    return;
  }

  // (2) 네트워크 문제 → 사용자에게 즉각 안내해야 함
  if (error instanceof NetworkError) {
    alert("네트워크 연결이 원활하지 않습니다. 잠시 후 다시 시도해주세요.", {
      onClose: errorCallback?.onNetworkErrorCallback,
    });
    return;
  }

  // (3) 서버가 응답은 했지만 비즈니스 로직 실패
  if (error instanceof OrderHttpError) {
    alert(error.message, params);
    return;
  }

  // (4) JS Error(TypeError, ReferenceError 등)
  if (error instanceof Error) {
    alert(error.message, params);
    return;
  }

  // (5) 진짜 정체를 모르는 에러
  alert(defaultHttpErrorMessage, params);
};
```

### 인터셉터를 활용한 에러 처리

위에서 작성했던 httpErrorHandler를 Axios의 인터셉터 기능을 활용하여 http에러에 일관된 로직을 적용할 수 있다.

```ts
api.interceptors.response.use(
  (response) => {
    // 정상 응답 → 그대로 반환
    return response;
  },
  (error) => {
    // 에러 응답 → 우리가 만든 httpErrorHandler로 변환
    return httpErrorHandler(error);
    // 여기서 httpErrorHandler가 Promise.reject(new CustomError()) 를 반환함
  }
);
```

### 에러 바운더리를 활용한 에러 처리

에러 바운더리는 리액트 컴포넌트 트리에서 에러가 발생할 때 공통으로 에러를 처리하는 리액트 컴포넌트이다.  
에러 바운더리를 사용하면 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고, 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리할 수 있게 된다.

```ts
import React, { Component, type ReactNode, type ErrorInfo } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

/**
 * 기본 Error Boundary
 * - constructor에서 상태 정의
 * - getDerivedStateFromError로 UI fallback
 * - componentDidCatch로 로깅
 */
export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  // 자식 컴포넌트 렌더 중 에러 발생 시 state 업데이트
  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true };
  }

  // 실제 에러 객체와 error info를 받을 수 있음 (로그 전송용)
  componentDidCatch(error: Error, info: ErrorInfo) {
    this.setState({ hasError: true });
    console.error("ErrorBoundary caught an error:", error, info);
    // Sentry나 LogRocket 같은 에러 로깅 툴을 여기에 추가 가능
  }

  render(): React.ReactNode {
    const { children } = this.props;
    const { hasError } = this.state;
    return hasError ? <ErrorPage /> : children;
  }
}

const App = () => {
  return (
    <ErrorBoundary>
      <OrderHistoryPage />
    </ErrorBoundary>
  );
};
```

### 상태 관리 라이브러리에서 에러 처리

기타 상태관리 라이브러리를 통해서도 에러 처리를 다룰 수 있다.  
이는 단순히 에러 메시지를 보여주는 것보다 상태 머신처럼 동작하기 위함이 크다.  
또한 글로벌 UI가 꼬인 상태를 통합적으로 제어해야하는 경우 자주 쓰인다.

### react-query를 활용한 에러 처리

리액트쿼리를 사용하면 요청에 대한 상태를 반환해주기 때문에 요청 상태를 확인하기 쉽다.

```ts
export default function UserInfo() {
  const { data, isLoading, error } = useUserQuery();

  if (isLoading) return <p>불러오는 중...</p>;

  if (error) {
    return (
      <p style={{ color: "red" }}>
        {(error as Error).message ?? "알 수 없는 오류"}
      </p>
    );
  }

  return (
    <div>
      <h3>사용자 정보</h3>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}
```

## API 모킹

프론트엔드 개발을 진행하다보면 서버 API가 완성되기 전에 개발을 진행해야 하는 일이 종종 생긴다.  
이때 모킹이라는 방법을 활용할 수 있다.

### JSON 파일 불러오기

간단한 조회만 필요한 경우 json파일을 만들거나 자바스크립트 파일 안에 JSON 형식의 정보를 저장하고 export 해주는 방식을 사용하면 된다.  
이후 GET 요청에 파일 경로를 삽입해주면 조회 응답으로 원하는 값을 받을 수 있다.

```ts
// mock/service.ts
const SERVICE: Service[] = [
  {
    id: 0,
    name: "배달의 민족",
  },
  {
    id: 1,
    name: "만화경",
  },
];

export default SERVICE;

// api
const getService = ApiRequester.get("/mock/service.ts");
```

### NextApiHandler 활용하기

진행하는 프로젝트가 Next.js를 사용하고 있다면 NextApiHandler를 활용할 수 있다.  
NextApiHandler는 하나의 파일 안에 하나의 핸들러를 디폴트 익스포트로 구현해야 하며 파일의 경로가 요청 경로가 된다.

```ts
// api/mock/brand
import { NextApiHandler } from "next";

const BRANDS: Brand[] = [
  {
    id: 0,
    label: "배민스토어",
  },
  {
    id: 2,
    label: "비마트",
  },
];

const handler: NextApiHandler = (req, res) => {
  res.json(BRANDS);
};

export default handler;
```

### API 요청 핸들러에 분기 추가하기

요청 경로를 수정하지 않고 평소에 개발할 때 필요한 경우에만 실제 요청을 보내고 그 외에는 목업을 사용하여 개발하고 싶을 때 사용한다.

```ts
// utils/apiHandler.ts
import { api } from "./client";

export async function apiHandler<T>(
  requestFn: () => Promise<T>,
  mockFn?: () => T,
  useMock = false
): Promise<T> {
  if (useMock && mockFn) {
    console.log("[MOCK] 모드로 응답 반환");
    return Promise.resolve(mockFn());
  }
  return requestFn();
}
```

### axios-mock-adapter로 모킹하기

```ts
// api/mock/index.ts
import MockAdapter from "axios-mock-adapter";
import { api } from "../client";

// 개발일 때만 mock 켜기
if (import.meta.env.MODE === "development") {
  const mock = new MockAdapter(api, { delayResponse: 500 });

  // 예시: GET /user
  mock.onGet("/user").reply(200, {
    id: 1,
    name: "Mock User",
  });

  // 예시: POST /login
  mock.onPost("/login").reply((config) => {
    const body = JSON.parse(config.data);

    if (body.username === "test" && body.password === "1234") {
      return [200, { token: "mock-token-123" }];
    }

    return [401, { message: "로그인 실패" }];
  });

  console.log("%c[MOCK] Axios Mock Adapter 활성화됨", "color: green;");
}
```

위 예시 코드처럼 작성하고 현재 개발 모드라면 user로 들어오는 GET요청은 모킹을 타게 된다.  
또한 같은 원리로 login으로 들어오는 POST요청도 모킹으로 들어오게 된다.
