# 훅

## 리액트 훅

클래스 컴포넌트를 사용하던 시절에는 몇 가지 불편함이 있었다.

상태 로직 재사용이 어렵다.  
서로 다른 컴포넌트에서 같은 상태 로직을 반복해서 구현해야 한다.  
생명주기 메서드(componentDidMount 등)에 여러 종류의 로직이 섞인다.  
“데이터 요청”, “이벤트 등록”, “DOM 조작”처럼 서로 다른 관심사가 한 메서드에 몰린다.  
유지보수와 테스트가 어렵다.  
상태 변경에 따른 사이드 이펙트를 추적하기가 힘들다.

리액트 v16.8에서 Hook이 도입되면서 함수형 컴포넌트에서도 클래스 생명주기처럼 로직을 다룰 수 있게 되었고,
상태 로직을 자유롭게 추출하고 재사용하는 것이 가능해졌다.

### useState

useState는 가장 기본적인 상태 저장 훅이다.

```
function useState<S>(
  initialState: S | (() => S)
): [S, Dispatch<SetStateAction<S>>];

type Dispatch<A> = (value: A) => void;
type SetStateAction<S> = S | ((prevState: S) => S);
```

첫 번째 값: 상태(state)  
두 번째 값: 상태를 변경하는 함수(setState)  
파라미터:

- 새로운 상태 값 직접 전달
- 혹은 이전 상태를 기반으로 새로운 값을 계산하는 함수 전달
  둘 다 가능하다.

### TS와 함께 쓰면 상태 타입을 확실하게 보장할 수 있다

```
interface Member {
  name: string;
  age: number;
}

const MemberList = () => {
  const [memberList, setMemberList] = useState<Member[]>([]);

  const sumAge = memberList.reduce((sum, member) => sum + member.age, 0);

  const addMember = () => {
    setMemberList([
      ...memberList,
      {
        name: 'DokgoBaedal',
        agee: 11, // 🚨 age 오타 → TS가 바로 잡아줌
      },
    ]);
  };
};
```

→ 타입스크립트를 적용하면 잘못된 구조를 가진 객체가 들어오는 것을 즉시 차단할 수 있다.

### 의존성 배열을 사용하는 훅: useEffect & useLayoutEffect

#### useEffect

렌더링 이후 특정 작업을 실행할 때 사용한다.

```
function useEffect(effect: EffectCallback, deps?: DependencyList): void;
```

- effect → 실행할 함수
- deps → effect가 다시 실행될 조건

effect는 Promise를 반환하면 안 된다.
왜냐하면 비동기 실행 순서가 섞이면서 **경쟁 상태(Race Condition)**가 발생할 수 있기 때문이다.

#### 경쟁 상태(Race Condition)란?

둘 이상의 작업이 동시에 같은 자원에 접근하면서 실행 순서가 예측 불가한 상태를 의미한다.  
예를 들어 API 요청이 여러 번 동시에 발생하면, 먼저 끝난 요청의 값이 마지막 요청값을 덮어버리는 상황이 생길 수 있다.

#### 의존성 배열(deps)의 특징

deps의 요소는 **얕은 비교(shallow compare)**로 판단된다.

- 내부 값이 그대로여도 객체의 참조가 변경되면 다른 값으로 판단된다.
- 그래서 deps에 객체나 배열을 넣을 때는 항상 주의해야 한다.

```
const Label = ({ value }) => {
  const { id, name } = value;

  useEffect(() => {
    // ...
  }, [id, name]);
};
```

#### 클린업 함수(Destructor)

useEffect 내부에서 반환한 함수는 컴포넌트가 사라질 때 호출된다.

- deps가 없을 때 ([])  
   → 마운트 시 한 번 실행, 언마운트 시 한 번 클린업

- deps가 있을 때  
   → deps 값이 바뀔 때마다 기존 effect의 클린업이 먼저 실행되고, 새로운 effect 실행

#### useLayoutEffect

useEffect와 기능은 비슷하지만 실행되는 순서가 다르다.

실행 순서:

1. useLayoutEffect
2. Layout/Render
3. useEffect

즉, “화면에 그려지기 전에 반드시 처리해야 하는 작업” → useLayoutEffect 사용

### useMemo & useCallback — 메모이제이션 훅

두 훅은 “이전 연산 결과를 기억해두었다가 필요할 때 재사용”한다.

```
function useMemo<T>(factory: () => T, deps: DependencyList): T;
function useCallback<T extends Function>(callback: T, deps: DependencyList): T;
```

차이점

- useMemo → 값을 기억
- useCallback → 함수를 기억
  렌더링이 자주 일어나는 컴포넌트(예: form)에서 매우 유용하다.

### useRef — DOM 조회 및 값 저장

useRef는 크게 두 가지 용도로 쓰인다.

- DOM 직접 접근
- 값을 저장하지만 상태처럼 리렌더링을 발생시키지 않음

```
const ref = useRef<HTMLInputElement>(null);

const onClick = () => {
  ref.current?.focus();
};
```

#### useRef의 반환 타입

```
function useRef<T>(initialValue: T): MutableRefObject<T>;
function useRef<T>(initialValue: T | null): RefObject<T>;
```

- MutableRefObject: current 값을 변경할 수 있음
- RefObject: current는 readonly, 변경 불가

일반적으로 DOM ref는 `RefObject<T>` 형태를 사용한다.  
(초기값을 null로 넣으면 자동 적용)

### forwardRef로 자식 컴포넌트에 ref 전달하기

ref는 DOM 요소에만 직접 전달되므로, 컴포넌트에는 바로 전달되지 않는다.  
이때 forwardRef를 사용한다.

```
const MyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  return (
    <div>
      <label>{props.name}</label>
      <input ref={ref} />
    </div>
  );
});
```

forwardRef는 내부적으로 ref 타입을 `ForwardedRef<T>`로 변환하여 부모 컴포넌트가 사용할 수 있게 해준다.

### useRef의 특징 정리

- 값이 바뀌어도 리렌더링되지 않는다
- 상태보다 빠르게 조회할 수 있다
- DOM 요소를 직접 조작할 때 반드시 필요하다

### 훅의 규칙 2가지

- 항상 최상위 레벨에서 호출하기
  - 조건문, 반복문 안에서 호출 ❌
  - 이유: React는 훅의 호출 순서로 내부 상태를 관리함
- React 함수 컴포넌트 또는 커스텀 훅 안에서만 호출하기
  - 일반 함수나 클래스에서는 훅 사용 불가

### useImperativeHandle

자식 컴포넌트에서 특정 메서드를 노출하고 싶을 때 사용한다.  
(예: 부모가 자식의 내부 메서드를 직접 호출해야 하는 경우)

```
useImperativeHandle(ref, () => ({
  focus: () => { ... },
}));
```

forwardRef와 함께 동작한다.

## 커스텀 훅

반복되는 로직을 쉽게 빼서 재사용할 수 있다.  
이름은 반드시 use로 시작해야 한다.

### 나만의 훅 만들기 — useInput

```
const useInput = (initialValue) => {
  const [value, setValue] = useState(initialValue);

  const onChange = (e) => {
    setValue(e.target.value);
  };

  return { value, onChange };
};
```

사용 예시:

```
const { value, onChange } = useInput('');
```

### 타입스크립트로 useInput 강화하기

```
const useInput = (initialValue: string) => {
  const [value, setValue] = useState(initialValue);

  const onChange = useCallback((e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  }, []);

  return { value, onChange };
};
```

#### 장점

- value는 항상 string이라는 것이 보장됨
- onChange는 `<input>` 전용 이벤트만 허용
- 사용자가 잘못된 타입을 전달하면 즉시 에러 발생
