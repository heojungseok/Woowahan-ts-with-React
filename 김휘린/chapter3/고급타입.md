# 고급 타입

## 타입스크립트만의 독자적 타입 시스템

### any

any타입은 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다.

#### any를 사용해야하는 대표 사례

1. 개발 단계에서 임시로 값을 지정해야 할 때
2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
3. 값을 예측할 수 없을 때 암묵적으로 사용

그치만 any타입은 지양하는것이 좋다.  
tsconfig.json에서 noImplicitAny 옵션을 활성화하면 타입이 명시되지 않은 변수의 암묵적인 any 타입에 대한 경고를 발생시킬 수 있다.

### unknown

unknown 타입은 any 타입과 유사하게 모든 타입의 값이 할당될 수 있다.  
하지만 unknown 타입은 any 타입 외에 다른 타입으로 할당 불가능!!

#### known 타입이 필요한 이유

```javascript
let a: any = "hello";
a.trim(); // OK
a.toFixed(); // 런타임 에러 발생 가능 (string에는 없음)

let u: unknown = "hello";
u.trim(); // ❌ 오류: 'trim'은 'unknown' 타입에 없음

if (typeof u === "string") {
  u.trim(); // ✅ 타입 검사 후 안전하게 사용 가능
}
```

위 예시를 보자  
any타입의 값은 어떤 연산이나 속성접근도 자유로워서 잘못된 메서드를 사용해도 개발단계에서 알지 못한다.  
하지만 unknown은 모든 값은 담기지만 엄격한 타입 검사를 강제하여 안정성을 높혔다고 볼 수 있다.

### void

void는 이 함수가 아무것도 반환하지 않는다는것을 명확히 알려주기 위한 타입이다.

### never

`never` 타입은 값을 **절대 반환할 수 없는 타입**을 말한다.  
즉, **정상적으로 종료되지 않는 함수**를 표현할 때 사용된다.  
자바스크립트에서 값을 반환할 수 없는 예는 크게 두 가지로 나눌 수 있다.

#### 에러를 던지는 경우

함수 실행 도중 `throw` 문으로 예외를 발생시키면,  
그 이후의 코드는 절대 실행되지 않는다.  
따라서 이 함수는 어떤 값도 반환하지 않으므로 `never` 타입을 갖는다.

```ts
function throwError(message: string): never {
  throw new Error(message);
}
```

#### 무한히 함수가 실행되는 경우

함수가 무한 루프에 빠져 종료되지 않는 경우 역시 값을 반환할 수 없으므로 never 타입으로 표현한다.

```ts
function infiniteLoop(): never {
  while (true) {
    console.log("Running...");
  }
}
```

정리하자면, never는 다음과 같은 경우에 사용된다:

- 함수가 정상적으로 끝나지 않음
- 값을 반환하지 않음
- throw, 무한 루프, 도달 불가능한 코드 등

### Array

타입스크립트에서 배열 타입을 선언하는 여러가지 표현들이 있다.

#### []

대괄호([]) 형식을 이용하여 배열 타입을 선언할 수 있다.

```ts
const array: number[] = [1, 2, 3];
```

#### Array<>

이렇게 해도 가능하다.

```ts
const array: Array<number> = [1, 2, 3];
// number[] 와 동일하다.
```

#### 여러 원소 타입

유니온을 사용하여 여러 원소 타입을 지정할 수 있다.

```ts
// 원소에 string과 number가 혼용됨
const array1: Array<number | string> = [1, "string"];
const array2: (number | string)[] = [1, "string"];

// 아래의 경우는 원소가 혼용되진 못한다.
const array3: number[] | string[] = [1, 2];
const array4: number[] | string[] = ["string1", "string2"];
```

#### 튜플

```ts
let tuple: [number] = [1];
tuple = [1, 2]; //불가능
tuple = ["string"]; // 불가능

let tuple2: [number, string, boolean] = [1, "string", true]; //혼용가능
```

리액트에서 useState는 튜플 타입을 반환한다.  
첫 번째 원소는 훅으로부터 생성 및 관리되는 상태값을 의미하고  
두 번째 원소는 해당 상태를 조작할 수 있는 setter를 의미한다.

### enum

enum타입은 열거형이라고도 부르는데 타입스크립트에서 지원하는 특수한 타입이다.

```ts
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST",
}

function checkRole(role: Role) {
  if (role === Role.Admin) {
    console.log("관리자입니다.");
  } else {
    console.log("일반 사용자입니다.");
  }
}

checkRole(Role.Admin); // "관리자입니다."
```

---

## 타입 조합

### 교차 타입

교차타입이란 여러 타입을 합쳐서 동시에 만족하는 타입을 만드는 기능이다.

```ts
type A = { name: string };
type B = { age: number };

type Person = A & B;

const user: Person = {
  name: "휘린",
  age: 32,
};
```

### 유니온 타입

유니온타입은 교차타입과는 다르게 여러 타입 중 하나만 만족하면 되는 타입이다.

```ts
type Value = string | number;

let a: Value;

a = "hello"; // ✅ 문자열 가능
a = 123; // ✅ 숫자도 가능
a = true; // ❌ boolean은 불가
```

### 인덱스 시그니처

인덱스 시그니처란 객체의 key가 동적으로 정해질 때, 그 key와 value의 타입을 정의하는 문법이다.

```ts
type UserScores = {
  [key: string]: number;
};

// “모든 key는 string이고, value는 number”라는 뜻
```

### 인덱스드 엑세스 타입

타입 안에서 특정 프로퍼티의 타입을 꺼내서 재사용할 때 사용한다.  
즉, “이 타입의 이 키가 가진 타입”을 가져오는 문법이다.

```ts
type Person = {
  name: string;
  age: number;
};

type NameType = Person["name"]; // string
type AgeType = Person["age"]; // number
```

### 맵드 타입

기존 타입의 프로퍼티들을 변형(copy + transform) 해서
새로운 타입을 만드는 문법이다.  
즉, “타입에 for ... in을 적용하는 문법”이라고 보면 된다.

```ts
type User = {
  name: string;
  age: number;
};

type OptionalUser = {
  [K in keyof User]?: User[K];
};

//결과
type OptionalUser = {
  name?: string;
  age?: number;
};
```

### 템플릿 리터럴 타입

템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언할 수 있는 문법이다.

```ts
type Lang = "ko" | "en";
type Greeting = `hello-${Lang}`;

const msg1: Greeting = "hello-ko"; // ✅
const msg2: Greeting = "hello-en"; // ✅
const msg3: Greeting = "hello-ja"; // ❌ ("ja"는 포함되지 않음)
```

### 제네릭

타입을 함수의 매개변수처럼 전달받아서
재사용성과 타입 안정성을 동시에 확보할 수 있게 해주는 기능이다.

즉 타입에 타입을 넣는 함수와 같다.

```ts
interface ApiResponse<T> {
  data: T;
  success: boolean;
}

type User = { id: number; name: string };

const res: ApiResponse<User> = {
  data: { id: 1, name: "휘린" },
  success: true,
};
```

## 제네릭 사용법

### 함수의 제네릭

어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 함수에 제네릭을 사용하면 된다.

```ts
function identity<T>(value: T): T {
  return value;
}

identity<number>(10); // T = number
identity("hello"); // T = string (타입추론)
```

### 호출 시그니처의 제네릭

호출 시그니처는 타입스크립트의 함수 타입 문법으로 함수의 매개변수와 반환타입을 미리 선언하는것을 말한다.

쉽게 말하면 함수를 선언할 때 제네릭을 정의하는것이 아니라 미리 제네릭 함수 타입을 선언할 수 있다는 것이다.

```ts
type IdentityFn = <T>(value: T) => T;

const identity: IdentityFn = (v) => v;

identity(123); // T = number
identity("hello"); // T = string
```

### 제네릭 클래스

제네릭 클래스는 외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스이다.

```ts
class Box<T> {
  private value: T;
  constructor(value: T) {
    this.value = value;
  }
  getValue(): T {
    return this.value;
  }
}

const numberBox = new Box<number>(10);
const stringBox = new Box("Hello");

numberBox.getValue(); // number
stringBox.getValue(); // string
```

### 제한된 제네릭

이는 타입 매개변수에 대한 제약 조건을 설정하는 것을 말한다.

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const user = { name: "휘린", age: 30 };

getProperty(user, "name"); // ✅
getProperty(user, "age"); // ✅
getProperty(user, "email"); // ❌ "email"은 user에 없음
```

### 확장된 제네릭

제네릭 타입은 여러 타입을 상속받을 수 있으며 타입 매개변수를 여러 개 둘 수도 있다.

```ts
interface ApiResponse<T> {
  data: T;
  success: boolean;
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  totalCount: number;
}

const res: PaginatedResponse<{ id: number; name: string }> = {
  data: [{ id: 1, name: "휘린" }],
  success: true,
  totalCount: 10,
};
```
