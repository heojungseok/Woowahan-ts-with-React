# 타입스크립트 컴파일

## 런타임과 컴파일타임

**컴파일타임(compile time)**
코드를 **실행하기 전에** 검사하고 다른 형태로 바꾸는 시간.

- 예: 타입 검사, 문법 검사, TS → JS 변환

**런타임(runtime)**
코드가 **실제로 실행되는 시간**.

- 예: 브라우저에서 JS가 돌아가면서 DOM 조작, 네트워크 요청 등 수행

> **컴파일타임 = 실행 전 검사 / 변환 시간**  
> **런타임 = 실제로 코드가 동작하는 시간**

---

### 자바스크립트 런타임

자바스크립트는 **런타임에만 오류가 드러나는 동적 타입 언어**다.

```js
const user = "Hwirin";
user(); // ❌ 함수처럼 호출 → 실제 실행(런타임) 시에야 에러 발생
```

JS 엔진은 코드를 실행해 보기 전까지:

- `user`가 문자열인지 함수인지,
- 이 코드가 논리적으로 말이 되는지에 대해 **정적 타입 검사를 하지 않는다.**

이 때문에:

- 오타, 잘못된 호출, 잘못된 타입 사용 같은 문제가
- **배포 후, 사용자 환경에서** 터질 수 있다.

> 그래서 나온 아이디어가 바로 **TypeScript**:  
> “코드를 실행하기 전에(컴파일타임에) 최대한 많은 타입 오류를 잡자.”

---

### 타입스크립트 컴파일과 AST 기반 처리

타입스크립트는 크게 두 가지를 한다:

1. **코드 검사기(Code Checker)**: 타입이 맞는지, 잘못된 사용은 없는지 검사
2. **코드 변환기(Code Emitter)**: TS 코드를 브라우저/Node가 이해할 수 있는 **순수 JS 코드로 변환**

이 과정에서 중심이 되는 내부 표현이 **AST(Abstract Syntax Tree, 추상 구문 트리)** 다.

### AST란?

- 소스 코드를 **트리 구조**로 표현한 것
- 문자열 코드 → 토큰 → 트리(노드들)로 바꿔서, 컴파일러가 다루기 쉽게 만든 구조

예를 들어

```ts
const sum = (a: number, b: number) => a + b;
```

이 코드는 AST 기준으로 보면 대략 이런 정보를 가진다:

- `const` 선언
- 식별자: `sum`
- 값: 화살표 함수
- 매개변수: `a: number`, `b: number`
- 본문: `a + b` (이항 연산 노드)

타입스크립트 컴파일러는 이 AST를 기반으로:

- 각 식별자가 어떤 타입인지 추적하고
- 연산이 타입에 맞는지 검사하고
- 문제가 없으면 JS 코드로 내보낸다.

---

## 타입스크립트 컴파일러의 동작

### 코드 검사기로서의 타입스크립트 컴파일러

타입스크립트 컴파일러는 코드를 **실행하기 전에 검사하는 정적 분석기** 역할을 한다.

#### 자바스크립트 예시 (런타임에서야 터지는 오류)

```js
// JavaScript
const user = "Hwirin";
user(); // ❌ 문자열을 함수처럼 호출 → 런타임 에러
```

- 자바스크립트는 이 코드를 사전에 막지 못한다.
- 실제로 실행될 때까지는 엔진이 불만 없이 넘어간다.

#### 타입스크립트 예시 (컴파일타임에 잡히는 오류)

```ts
// TypeScript
const user: string = "Hwirin";

user();
// ❌ 에러: 이 식별자는 'string' 타입입니다. 호출할 수 없습니다.
```

- 타입스크립트 컴파일러는 이 코드를 JS로 변환하기 전에
- **"문자열을 함수처럼 호출했다"**는 사실을 파악한다.
- 따라서 **컴파일타임에 오류를 발생시켜** 배포 전에 버그를 잡을 수 있다.

> 즉, TS 컴파일러는 **코드 검사 도구(정적 분석기)**로서  
> **런타임에 터질 에러를 미리 잡는 역할**을 한다.

### 코드 변환기로서의 타입스크립트 컴파일러

타입스크립트는 결국 브라우저/Node가 이해할 수 있는 **자바스크립트로 변환되어야** 실행된다.

```ts
// TypeScript
const add = (a: number, b: number): number => {
  return a + b;
};
```

컴파일(트랜스파일) 후에는 다음과 같은 순수 JS 코드가 된다:

```js
// JavaScript (emit 결과)
const add = (a, b) => {
  return a + b;
};
```

- **타입 정보(`: number`)는 전부 사라진다.**
- 런타임에는 타입 정보가 필요 없고, 오직 값만 필요하기 때문.

> 타입스크립트 컴파일러는 "타입을 검사한 뒤, 타입 정보를 제거하고 JS 코드만 남기는 변환기"라고 볼 수 있다.

## 타입스크립트 컴파일러의 구조

타입스크립트 컴파일러는 크게 다음과 같은 단계로 동작한다:

1. **Scanner (스캐너)**
2. **Parser (파서)**
3. **Binder (바인더)**
4. **Checker (체커)**
5. **Emitter (이미터)**

### 1 Scanner (스캐너)

- 소스 코드를 문자 단위로 읽어서 **토큰(token)** 단위로 쪼갠다.
- 예: `const`, `=`, `identifier`, `number literal` 같은 최소 단위로 분리.

### 2 Parser (파서)

- 스캐너가 만든 토큰들을 읽고 **AST(Abstract Syntax Tree)** 를 만든다.
- 문장, 표현식, 선언 등을 노드로 갖는 트리 구조로 변환.

### 3 Binder (바인더)

- AST를 순회하면서 **선언과 참조를 연결**한다.
- 어떤 식별자가 어떤 스코프/심볼에 속하는지, 어떤 선언을 가리키는지 결정.

  - 예: `sum`이 어느 함수/변수 선언인지, `a`, `b`가 어떤 파라미터인지.

### 4 Checker (체커)

- 바인딩된 심볼 정보를 이용해서 **타입을 계산하고 검사**한다.
- "이 표현식의 타입은 무엇인가?", "이 호출은 올바른 인자를 사용했는가?" 같은 질문을 해결.
- 타입 오류가 있으면 이 단계에서 보고된다.

### 5 Emitter (이미터)

- 최종 AST를 기반으로 **자바스크립트 코드**를 출력한다.
- 타입 정보는 제거하고, 선택한 타깃(`ES5`, `ES2015` 등)에 맞는 JS로 변환.

### 6 전체 흐름 정리

```text
소스 코드 (.ts)
  ↓
Scanner   : 코드 → 토큰 목록
  ↓
Parser    : 토큰 → AST
  ↓
Binder    : 선언/참조 연결 (심볼/스코프 구성)
  ↓
Checker   : 타입 분석 및 오류 검사
  ↓
Emitter   : AST → JavaScript 코드 출력
```

> 요약하면, 타입스크립트 컴파일러는
> **코드를 파싱하고(AST), 심볼과 타입을 계산해 검사한 뒤, 타입을 제거한 JS를 내보내는 파이프라인**이라고 이해하면 된다.
