# 타입스크립트만의 독자적 타입 시스템

## any 타입
모든 값을 오류 없이 받을 수 없는 타입.
```ts
let state: any;
stae = { value: 0};
state = 100;
state = "hello";
state.foo.bar = () => console.log("ㅎㅇ")
```
값을 예측할 수 없을때 암묵적 사용(API반환값 처리,개발 단계)



## unKnown 타입
any를 제외한 다른 타입으로 선언된 변수에는 unkown 타입 값을 할당할 수 없다.

| any    | unknown                                    |
| ---------- | ---------------------------------------------- |
| 어떤 타입이든 any 타입에 할당이 가능 | 어떤 타입이든 unkown 타입에 할당가능               |
| any 타입은 어던 타입으로도 할다가능 never을 제외한 | unkown 타입은 any 타입 외에 다른 타입으로 할당 불가능|

```ts
let unkownValue: unkown;

unkownValue = 100;
unkownValue = "hello world";
let someValue1: number = unkownValue; // number 타입에 변수할당 불가
let someValue2: string = unkownValue; // 마찬가지
```
unknownValue의 타입은 정해져 있지 않으므로
변수에 할당이 불가능하다
그러므로
타입을 정제한 후에 사용이 가능하다!

```ts
let unknownValue: unknown;
unknownValue = "문자임"
let a: string

if (typeof unknownValue === 'string') {
    a = unknownValue  // string
}
```



## void 타입
은 반환 값이 정해져 있지 않은 경우 사용


## never 타입
반환할 수 없는 타입을 말함.
에러를 던지는 경우와 무한히 함수가 실행되는 경우.


```ts
const errorFunc=(): never=>{
    throw new Error("테스트 에러");
}

const infFunc= (): never =>{
    while(true){}
}

// foo1, foo2는 never타입
const foo1=errorFunc();
const foo2=infFunc();

```


## Array 타입

```ts
const array = [1,"string",fn] // 자바스크립트의 경우 배열에 숫자,문자열,함수등을 넣을 수 있다.
```
위 코드는 타입스크립트의 정적 타이핑과 부합하지 않는다.

```ts
const array:number[] = [1,2,3] // 원소의 타입이 숫자만 가능한 배열
```
명시적인 타입을 선언하여 타입의 원소를 관리하는 것을 강제한다. 위처럼

숫자형과 문자열 등 여러 타입을 관리 해야하는 배열의 경우 아래처 유니온 타입을 사용할 수 있다.
```ts
const array1: Array<number | string> = [1,"string"];

const array3 : (number | string) [] = [1,"string"];
```
배열의 타입명시는 길이 제한이 가능하지 않았지만,

튜플은 배열타입의 하위 타입으로 기존 타입스크립트의 배열 기능에 길이 제한 까지 추가한 타입 시스템이라고 볼 수 있다.
```ts
// 대괄호 안에 선언하는 타입의 개수가 튜플이 가질 수 있는 원소의 개수를 나타낸다. 튜플은 배열의 특정 인덱스에 정해진 타입을 선언하는 것과 같다.
let tuple:[nmber] = [1];

tuple = [1,2] // 불가능
```

## enum 타입
```ts
enum ProgrammingLanguage {
  TypeScript, //0
  JavaScript, //1
  ... //2
  ...  //3
}
  Programming.TypeScript // 0
  Programming["JavaScript"] // 1}
```
위 코드처럼 enum 타입은 값을 명시하지 않는 경우
0부터 1씩 늘려가며 값을 할당해준다.

```ts
enum ProgrammingLanguage {
  TypeScript - "typescript",
  Java = 300,
  Python = 400,
  Kotlin, //401
  Rust, // 402
}
```
명시도 가능하다 명시를 하다 누락된 멤버는 이전 멤버값의 숫자를 기준으로 1씩 늘려가며 자동으로 할당된다.



## 제네릭

다양한 타입 간에 재사용성을 높이기 위해 사용하는 문법
```ts
type ExampleArrayType<T> = T[];
const array1: ExampleArrayType<string> = ["치킨","피자","우동"]
```
타입 string을 받아 string[]을 따르게 한다

제네릭 함수를 호출할 때 반드시 꺽쇠괄호안에 타입을 명시해야 하는 것은 아니다.
타입을 명시하는 부분을 생략하면 컴파일러가 인수를 보고 타입을 추론해준다
```ts
function Func<T>(arg: T): T[] {
  return new Array(3).fill(arg);
}

Func("hello"); // T는 string으로 추론된다
```


## 교차 타입

여러 가지 타입을 결합 하여 하나의 단일 타입으로 만들 수 있다.

& 사용하여 표기

결과물로 탄생한 단일 타입에는 타입별칭을 붙일 수 도 있다.

타입 C가 타입A와B의 교차 타입 
A & B라면 타입 C는 타입 A와 타입B의 모든 멤버를 가지고 있는 타입이다.

```ts
type A = { value1: string };
type B = { value2: number };

type C = A & B;

cosnt array:C = {value1: "문자임", value2: 123}  // 무조건 속성 다있어야함


const func1 = (item:C): void => (
  item.value1  // 된다
  item.value2 // 되어요
)

```




## 유니온 타입
```ts
type A = { value1: string };
type B = { value2: number };

type C = A | B;

cosnt array:C = {value1: "문자임", value2: 123}  // 속성이 다있어도되고
cosnt array:C = {value1: "문자임"} // 하나만 있어도 된다
cosnt array:C = {value2: 123}

const func1 = (item:C): void => (
  item.value1  // 안된다
  item.value2 // 이것들은 속성이 겹치는게 없으니가 접근이안된
)

```
타입 A 또는 B 중 하나가 될 수 있는 타입이며 A|B로 표기한다.

접근 시에는 겹치는 타입만 가능

만약 접근하고 싶다면 타입좁히기나 타입단언을 이용하면 된다고 한다.
```ts
const func1 = (item: C): void => {
  if ("value1" in item) {
    console.log(item.value1); // ✅ OK (A 타입으로 좁혀짐)
  } else {
    console.log(item.value2); // ✅ OK (B 타입으로 좁혀짐)
  }
};

const func1 = (item: C): void => {
  console.log((item as A & B).value1);
  console.log((item as A & B).value2);
};

```
## 인덱스 시그니처

특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을때 사용하는 문법이다.
인터페이스 내부에서 [key: K]:T꼴로 명시함.

```ts
interfacae IndexSigantureEx2{
  [Key:string]: number | boolean;
  length: number,
  inValid: boolean,
  name: string // 에러 발생
}
```
값의 타입이 number이나 boolean 경우여야 하므로 name속성의 경우 에러 발생함.


## 맵드 타입
기존 타입의 속성들을 순회(map)하면서 새로운 타입을 만드는 문법

```ts
type Example = {
  a: number;
  b: string;
  c: boolean;
}

type Subset<T> = {
  [K in keyof T]?: T[K];
}

  const aExample: Subset<Example> = {a: 3};
  const bExample: Subset<Example> = {b: "hello"};
  const acExample: Subset<Example> = {a: 4, c: true};
```
Example의 경우 a,b,c 속성이 무조건 들어가야함
Subset은 Example의 속성들을 따르지만 들어가도되고 안되고
재사용을 위해 optional하게 사용하기 위해서이다


## 템플릿 리터럴 타입
템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언할 수 있는 문법

```ts
type Stage =
  | "init"
  | "select-image"
  | "edit-image"
  | "decorate-card"
  | "capture-image";
type StageName = `${Stage}-state`;

// 'init-stage' | 'select-image-stage' | ....
```

```ts
type Api = "login" | "logout" | "register";
type ApiPath = `/api/${Api}`;

const endpoint: ApiPath = "/api/login"; // ✅ OK
const wrong: ApiPath = "/api/delete";   // ❌ Error
```
위 처럼 사용하려고 ? 하는 문법.?



