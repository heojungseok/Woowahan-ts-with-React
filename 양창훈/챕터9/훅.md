

# 리액트 훅

리액트 훅이 도입되면서 함수 컴포넌트에서도 클래스 컴포넌트와 같이 컴포넌트의 생명주기에 맞춰 로직을 실행할 수 있게 되었다.
이에 따라 비즈니스 로직을 재사용하거나 작은단위로 코드를 분할하여 테스트하는게 용이해졌으며 관심사에 맞게 분리 구성하여 구성할 수 있게 되었다.

## useState

```ts
function useState<S>(
  initialState: S | (() => S)
): [S, Dispatch<SetStateAction<S>>];

type Dispatch<A> = (value: A) => void;
type SetStateAction<S> = S | ((prevState: S) => S);
// useState 타입정의
// 튜플의 첫번째 요소는 제네릭으로 지정한 ㄴ xkdlqdlek
// 두번째 요소는 상태를 업데이트 할 수 있는 Dispatch 타입의 함수이다.
```

useState에 타입스크립트를 적용하면 강력한 힘을 가지게 된다고 한다

```ts
const [memberList, setMemberList] = useState([
  {
    name: "KingBaedal",
    age: 10,
  },
  {
    name: "MayBaedal",
    age: 9,
  },
]);

const sumAge = memberList.reduce((sum, member) => sum + member.age, 0);

const addMember = () => {
  setMemberList([
    ...memberList,
    {
      name: "DokgoBaedal",
      agee: 11, // 
    },
  ]);
};

console.log(sumAge) // NaN sumAge 호출 시 agee의 값이 Nan되어 예상치 못한 사이드 이펙트가 발생한다

```

위와 같은 사이드 이펙트는 타입스크립트를 사용하면 에러를 사전에 방지할 수 있다.


## useEffect

```ts
type SomeObject = {
  name: string;
  id: string;
};

interface LabelProps {
  value: SomeObject; //객체
}

const Label: React.FC<LabelProps> = ({ value }) => {
  useEffect(() => {
    /* 수행할 일 */
  }, [value]);
};

```
위처럼 객체자체를 의존성 배열에 두면 참조값이 계속변경되어 원치 않은 렌더링이 발생할 수 있따.


```ts
// after
const Label: React.FC<LabelProps> = ({ value }) => {
  const { id, name } = value;
  useEffect(() => {
    /* 수행할 일 */
  }, [id, name]); // value.name과 value.id 대신 name, id 직접 사용
};
```
따라서 분해해서 사용하도록!

근데 왜 이게 타입스크립트 useEffect 에시지 ?



## useRef

리액트 애플리케이션에서 <input />요소에 포커스를 설정하거나 특정 컴포넌트의 위치로 스크롤을 하는 등 DOM을 직접 선택해야 하는 경우에 사용한다.

```ts
import { useRef } from "react";

export default function MyInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus(); // TS가 정확히 타입 체크해줌
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>포커스</button>
    </>
  );
```

inputRef.current의 타입이 HTMLInputElement | null

focus(), value 등 모든 DOM API 자동 완성 가능.

js에서는 ref.current.focus()가 잘못돼도 에러 못 잡음.
ts는 잡아줌.


## 커스텀 훅

**타입스크립트로 커스텀훅 강화하기**

```ts
// hooks/useInput.tsx
import { useState, useCallback } from "react";

const useInput = (initialValue) => {
  const [value, setValue] = useState(initialValue);
  const onChange = useCallback((e) => {
    setValue(e.target.value);
  }, []);
  return { value, onChange };
};

export default useInput;
```
위 코드 실행 시 initialValue와 onCahnge함수의 인자로 넣어준 e의 타입이 지정되지 않아 에러가 발생한다.
이때 두 군데 모두 타입을 명시적으로 정의해주면 해결된다

```ts
// after
import { ChangeEvent, useCallback, useState } from "react";

const useInput = (initialValue: string) => {
  // 인자 타입 추가
  const [value, setValue] = useState(initialValue);
  const onChange = useCallback((e: ChangeEvent<HTMLInputElement>) => {
    // 이벤트 타입 추가
    setValue(e.target.value);
  }, []);
  return { value, onChange };
};

export default useInput;
```

그냥 인자에 타입 붙여주는게 강화라는 건가 ?

