

# 리액트 훅

리액트 훅이 도입되면서 함수 컴포넌트에서도 클래스 컴포넌트와 같이 컴포넌트의 생명주기에 맞춰 로직을 실행할 수 있게 되었다.
이에 따라 비즈니스 로직을 재사용하거나 작은단위로 코드를 분할하여 테스트하는게 용이해졌으며 관심사에 맞게 분리 구성하여 구성할 수 있게 되었다.

## useState

```ts
function useState<S>(
  initialState: S | (() => S)
): [S, Dispatch<SetStateAction<S>>];

type Dispatch<A> = (value: A) => void;
type SetStateAction<S> = S | ((prevState: S) => S);
// useState 타입정의
// 튜플의 첫번째 요소는 제네릭으로 지정한 ㄴ xkdlqdlek
// 두번째 요소는 상태를 업데이트 할 수 있는 Dispatch 타입의 함수이다.
```

useState에 타입스크립트를 적용하면 강력한 힘을 가지게 된다고 한다

```ts
const [memberList, setMemberList] = useState([
  {
    name: "KingBaedal",
    age: 10,
  },
  {
    name: "MayBaedal",
    age: 9,
  },
]);

const sumAge = memberList.reduce((sum, member) => sum + member.age, 0);

const addMember = () => {
  setMemberList([
    ...memberList,
    {
      name: "DokgoBaedal",
      agee: 11, // 
    },
  ]);
};

console.log(sumAge) // NaN sumAge 호출 시 agee의 값이 Nan되어 예상치 못한 사이드 이펙트가 발생한다

```

위와 같은 사이드 이펙트는 타입스크립트를 사용하면 에러를 사전에 방지할 수 있다.

